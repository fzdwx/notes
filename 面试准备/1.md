![image-20200917203225646](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200917203225.png)

![image-20200917203313163](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200917203313.png)





# 一、volatile是什么？

是jvm提供的轻量级的同步机制

-   保证可见性
-   不保证原子行
-   禁止指令重排(有序)



## 1、JMM-Java内存模型

Java Memory Model(java内存模型)；本身是一种抽象的概念本不存在，是一组规范,顶一个程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式

**关于同步的规定：**

1.  线程解锁前，必须把共享的变量的值刷新会主内存
2.  线程加锁前，必须读取主内存中最新的值到自己的工作内存中
3.  锁是同一把锁

由于jvm运行程序的实体是线程，而每个线程创建时jvm都会为其创建一个工作内存，工作内存是 线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享区域，所有线程都可以访问，==但线程对变量的操作必须在工作内存中进行，首先将变量从工作内存中读取到自己的工作区域，进行操作且完成后，在将变量刷新回主内存==，而不能直接操作柱内存中的变量，各个线程中的工作内存是==主内存中的变量的副本==，因此不同线程无妨相互访问变量，线程之间的通信（传值）不许通过主内存完成



## 2、JMM三大特性

1.  可见性
2.  原子性
3.  可见性



## 3、Volatile-可见性

数据发生改变马上就会刷新到主内存中，其他线程就能读取到这个数据的最新值，没加volatile程序就会一直运行下去

![image-20200918103857527](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918103904.png)

```java
public class VolatileDemo {
    public static void main(String[] args) {
        MyData data = new MyData();
        new Thread(() ->{
            System.out.println(Thread.currentThread().getName()+"\t come in");
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            data.addNumber();
            System.out.println(Thread.currentThread().getName()+"\t update number:"+data.number);
        },"addData").start();

        while (data.number == 0) {

        }
        System.out.println(Thread.currentThread().getName()+"\t over");
    }
}
class MyData {
    int number = 0;

    public void addNumber() {
        this.number = 60;
    }
```

加上volatile关键字

![image-20200918104005424](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918104005.png)



## 4、Volatile-原子性

volatile不保证原子性

所有的操作都是有效的，不可分割，完整性，某个线程正在做某个业务时，中间不可以被分割。需要整体完整，要么同时成功，要么同时失败

```java
public static void main(String[] args) {
    MyData data = new MyData();
    for (int i = 1; i < 10; i++) {
        new Thread(() -> {
            for (int j = 0; j < 1000; j++) {
                data.add();
            }
        }, String.valueOf(i)).start();
    }
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    //如果保证原子性，结果应该是9000
    System.out.println(data.number);
}
```

![image-20200918111007719](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918111007.png)

结果为8571，即volatile不保证原子性



### 4.2、解决原子性

1.  加sync
2.  atomic

![image-20200918113824539](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918113824.png)

![image-20200918113928185](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918113928.png)





## 5、Volatile-禁止指令重排序（有序）

volatile实现==禁止指令重排优化==，从而避免多线程环境下程序出现乱序执行的现象，先了解一个概念：==内存屏障==(Memory Barrier)是一个CPU指令，作用：

-   保证特定操作的执行顺序
-   保证某些变量的内存可见性(利用这个特性实现volatile的内存可见性)

在指令间插入一条==Memory Barrier==则会告诉编译器和CPU，不管什么指令都不能和这条==Memory Barrier==指令排序，==通过插入内存屏障禁止在内存屏障前后的指令执行重排优化==，另一个作用是强制刷新各种CPU的缓存数据

![image-20200918123753133](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918123753.png)

计算机在执行程序时，为了提高性能，编译器和处理器常常会对==指令重排==

![image-20200918115201836](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918115201.png)

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致

处理器在进行重排序时必须要考虑指令之间的==数据依赖性==

多线程环境中线程交替执行，由于编译器优化重拍的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

![image-20200918120156219](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918120156.png)



## 6、单例模式-volatile

```java
class Singleton {
    private Singleton() {
        System.out.println(Thread.currentThread().getName()+"\t Singleton的构造方法");
    }
    private static  Singleton instance = null;
    public static Singleton getInstance() {

        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public static void main(String[] args) {
        for(int  i = 1;i<10;i++){
            new Thread(()->{
                Singleton.getInstance();
            },String.valueOf(i)).start();
        }
    }
}
```

### 不加锁

![image-20200918125241636](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918125241.png)

### 加锁

![image-20200918125412789](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918125412.png)



### 双重检查

```java
public static  Singleton getInstance() {
    //第一次检查
    if (instance == null) {
        synchronized (Singleton.class) {
            //第二次检查
            if (instance == null) {
                instance = new Singleton();
            }
        }
    }
    return instance;
}
```

![image-20200918125610048](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918125610.png)





### 防止指令重排

双重检查不一定完全安全，因为有指令重排的存在，加入volatile

![image-20200918131826263](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200918131826.png)





# 二、CAS(compare and swap)