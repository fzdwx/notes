

# +商城首页-整合thymeleaf

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

![image-20201119143349248](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201119143356.png)



# 渲染一级分类

```java
package com.like.mall.product.controller.web;
/**
 * @author like
 * @since 2020-11-19 14:49
 * web 路径跳转
 */
@Controller
public class IndexController {
    @Resource
    CategoryService categoryService;

    @GetMapping({"/", "/index.html"})
    public String indexPage(Model model) {
        // 1.查询所有的一级分类
        List<CategoryEntity> ens = categoryService.getLevelFirstCategory();
        model.addAttribute("data",ens);
        return "index";
    }
}
```

~~~xml

    <select id="getLevelFirstCategory" resultType="com.like.mall.product.entity.CategoryEntity">
        select * from `mall-product`.pms_category
        where parent_cid = 0;
    </select>

~~~



![image-20201119151335185](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201119151335.png)



# 获取所有二级分类和三级分类的json

```java
/**
     * 获取所有二级和三级分类的json数据
     *
     * @return {@link Map<String, List<Catelog2Vo>>}
     */
@ResponseBody
@GetMapping("/index/catalog.json")
public Map<String, List<Catelog2Vo>> getCatalogJson() {
    return categoryService.getCatalogJson();
}
}



@Override
public Map<String, List<Catelog2Vo>> getCatalogJson() {
    // 1.找出所有的一级分类
    List<CategoryEntity> level1 = getLevelFirstCategory();

    // 2.封装数据
    return level1.stream()
        .collect(Collectors.toMap(k -> k.getCatId().toString(), v -> {
            // 3.查找当前一级分类下的二级分类
            List<CategoryEntity> level2 = baseMapper.selectList(new QueryWrapper<CategoryEntity>()
                                                                .eq("parent_cid", v.getCatId()));

            // 4.封装二级分类vo
            List<Catelog2Vo> vo2s = new ArrayList<>();
            if (level2 != null) {
                vo2s = level2.stream()
                    .map(i2 -> {
                        Catelog2Vo Vo2 = new Catelog2Vo();
                        Vo2.setCatalogId(String.valueOf(v.getCatId()));
                        Vo2.setId(i2.getCatId().toString());
                        Vo2.setName(i2.getName());

                        // 5.寻找三级分类
                        List<CategoryEntity> level3 = baseMapper.selectList(new QueryWrapper<CategoryEntity>()
                                                                            .eq("parent_cid", i2.getCatId()));

                        // 6.封装三级级分类vo
                        List<Catelog2Vo.Catelog3Vo> vo3s = null;
                        if (level3 != null) {
                            vo3s = level3.stream().map(i3 -> {
                                Catelog2Vo.Catelog3Vo Vo3 = new Catelog2Vo.Catelog3Vo();
                                Vo3.setCatalog2Id(i3.getParentCid().toString());
                                Vo3.setId(i3.getCatId().toString());
                                Vo3.setName(i3.getName());
                                return Vo3;
                            }).collect(Collectors.toList());
                        }
                        Vo2.setCatalog3List(vo3s);

                        return Vo2;
                    }).collect(Collectors.toList());
            }
            return vo2s;
        }));
}
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Catelog2Vo {
    private String catalogId; // 一级父分类id
    private List<Catelog3Vo> catalog3List; // 三级子分类id
    private String id;
    private String name;

    /**
     * 二级分类vo
     *
     * @author like
     * @date 2020/11/22 16:47:07
     */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Catelog3Vo {
        private String catalog2Id;
        private String id;
        private String name;
    }
}

```



# nginx搭建域名访问环境（反向代理）

> 1.在hosts中添加配置
>
> ip(nginx所在的ip) like.mall.com
>
> 2.让nginx进行反向代理，所有请求like.mall.com->发送到商城首页

![image-20201128123435539](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128123442.png)

# nginx的配置文件

~~~bash
vim /root/app/nginx/conf/nginx.conf

# 全局块 配置影响nginx的全局指令，如：用户组，pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

# events块 配置影响nginx服务器或用户的网络连接 如：每个进程的最大连接数，选取哪种数据驱动模型处理连接请求，是否允许同时接受多个网络连接，开启多个网络连接序列化等
events {
    worker_connections  1024;
}

# http块 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置，如文件引入，mime-type定义，日志自定义，是否使用sendifle传输文件，连接超时时间，单连接请求数等
http {
	# http全局块 如upstream，错误页面连接超时等
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
    
  # server块 配置虚拟主机的相关参数，一个http中可以有多个server 
  server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    charset utf-8;
    #access_log  /var/log/nginx/host.access.log  main;
	
	# location 配置请求的路由，以及各种页面的处理情况
    location / {
        charset utf-8;
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
}

~~~



# 压力测试-jemter

- 响应时间：用户从客户端发起一个请求到客户端接收从服务端返回的响应结束所耗费的时间
- hps：每秒点击次数 
- tps：系统每秒处理数
- qps：每秒处理查询次数

![image-20201128124654161](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128124654.png)

![image-20201128124940644](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128124940.png)

![image-20201128131518478](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128131518.png)



# nginx动静分离

1.把static中的index上传到nginx中的html中

![image-20201128140222133](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128140222.png)

![image-20201128140209507](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128140209.png)

2.在所有请求路径中添加/static/

3.修改配置文件

![image-20201128140722659](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201128140722.png)





# 缓存和分布式锁

## 缓存的使用

为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而db承担数据落盘工作。

### **哪些数据适合放入缓存中？**

1. 即时性、数据一致性要求不高
2. 访问量大且更新评率不高的数据(读多，写少)

![image-20201201111629261](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201111636.png)

~~~java
data = cache.load(id);    // 从缓存中加载数据
if(data == null){
    data = db.load(id);   // 从数据库中加载数据
    cache.put(id,data);   // 放入缓存中
}
return data;
~~~



### 使用redis作为缓存

引入jar包

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

添加配置文件

![image-20201201114130223](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201114130.png)

![image-20201201124717725](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201124717.png)







## 高并发下的缓存失效

### 缓存穿透

指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这个次查询的null写入缓存，这将导致这个不存在的数据每次请求都要去存储层去查询，失去了缓存的意义

**风险**

利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃

**解决**

null结果缓存，并加入短暂过期时间	



### 缓存雪崩

指在我们设置缓存时key采用了相同的过去时间，导致缓存在某一时刻同时失效，请求全部转发到db，db瞬时压力过重雪崩

**解决**

原有的失效时间基础上增加一个随机值

![image-20201201140411580](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201140411.png)

### 缓存击穿

- 对于一些设置了过期时间的key，如果这些key可能会在某些时间点被高并发的访问，是一种非常“热点”的数据
- 如果这个key在大量请求同时进来前刚好失效，那么对这个key的数据查询都落到db上，就是~

**解决**

加锁，大量并发只让一个去查，其他人就会等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据，不用到db

使用本地锁，保证查询数据和放入redis缓存中是一个原子性操作，这样可以避免查询2次数据库

![image-20201201143112999](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201143113.png)

![image-20201201142008339](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201142008.png)

![image-20201201142022275](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201201142022.png)

## 分布式加锁

在使用本地锁解决上面的问题的情况下，但是在分布式的情况中，如果启动了多个同一个项目就会查询多次，而不是只查一次。

本地锁只能锁住当前进程，而其他进程仍然会进行查询。



### 基本原理

使用redis 中的==set  key value  NX==这个命令，在多个同一个服务往redis中设置值的时候，这个命令的作用是如果存在就不设置了。这样就一次只会有一个服务能够执行。

![image-20201202120440524](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202120447.png)

![image-20201202125536993](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202125537.png)

![image-20201202125617086](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202125617.png)

```
getDataFromDb()就是最开始的方法，提取出来了。
因为getCatalogJsonFromDbWithLocalLock()和getCatalogJsonFromDbWithRedisLock()都重复了这个方法。
```



### 分布式锁演进-阶段一(由于业务原因造成死锁)



**问题**：

如果占好锁以后由于业务原因宕机了就会造成==死锁==。

**解决**：

设置锁的自动过期时间，即使没有删除，也会自动删除

![image-20201202122828289](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202122828.png)

![image-20201202130443123](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202130443.png)



### 分布式锁演进-阶段二(把设置lock和设置过期时间调整为一个原子操作)

![image-20201202130639200](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202130639.png)![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202130940.png)

### 分布式锁演进-阶段三

![image-20201202132434000](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202132434.png)

![image-20201202133023510](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202133023.png)



### 最终-保证获取值进行对比和删除的是一个原子操作

![image-20201202135525439](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202135525.png)

![image-20201202135747075](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202135747.png)



# redisson

https://github.com/redisson

## 使用

导入jar包

```xml
<!--使用redission作为所有分布式锁，分布式对象功能框架-->
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.14.0</version>
</dependency>
```

添加配置类

```java
@Configuration
public class RedissonConfig {

    /**
     * 所有对redisson的使用都是通过RedissonClient对象
     *
     * @return {@link RedissonClient}* @throws IOException ioexception
     */
    @Bean(destroyMethod = "shutdown")
    public RedissonClient redissonClient() throws IOException {
        Config config = new Config();
        // 1、使用单节点模式
        config.useSingleServer()
                .setAddress("redis://47.112.150.204:6379");
        return Redisson.create(config);
    }
}
```



##  可重入锁测试

~~~java
  /**
   * a、锁会自动续期，默认续期到30s，不用担心业务时间过长，导致锁过期被删除
   * b、加锁的业务只要运行完成，就不会续期，当完成后就会在30s内删除
   */
   可重入锁测试
~~~



![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201202150434.png)

基于Redis的Redisson分布式可重入锁[`RLock`](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLock.html) Java对象实现了`java.util.concurrent.locks.Lock`接口。同时还提供了[异步（Async）](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html)、[反射式（Reactive）](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html)和[RxJava2标准](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html)的接口。

```
RLock lock = redisson.getLock("anyLock");
// 最常见的使用方法
lock.lock();
```

大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改[Config.lockWatchdogTimeout](https://github.com/redisson/redisson/wiki/2.-配置方法#lockwatchdogtimeout监控锁的看门狗超时单位毫秒)来另行指定。

另外Redisson还通过加锁的方法提供了`leaseTime`的参数来指定加锁的时间。超过这个时间后锁便自动解开了。

~~~java
// 加锁以后10秒钟自动解锁
// 无需调用unlock方法手动解锁
lock.lock(10, TimeUnit.SECONDS);

// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
if (res) {
   try {
     ...
   } finally {
       lock.unlock();
   }
}
~~~

Redisson同时还为分布式锁提供了异步执行的相关方法：

```
RLock lock = redisson.getLock("anyLock");
lock.lockAsync();
lock.lockAsync(10, TimeUnit.SECONDS);
Future<Boolean> res = lock.tryLockAsync(100, 10, TimeUnit.SECONDS);
```

`RLock`对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出`IllegalMonitorStateException`错误。但是如果遇到需要其他进程也能解锁的情况，请使用[分布式信号量`Semaphore`](https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器#86-信号量semaphore) 对象.

## 公平锁

基于Redis的Redisson分布式可重入公平锁也是实现了`java.util.concurrent.locks.Lock`接口的一种`RLock`对象。同时还提供了[异步（Async）](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html)、[反射式（Reactive）](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html)和[RxJava2标准](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html)的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。

```java
RLock fairLock = redisson.getFairLock("anyLock");
// 最常见的使用方法
fairLock.lock();
```



## 读写锁

基于Redis的Redisson分布式可重入读写锁[`RReadWriteLock`](http://static.javadoc.io/org.redisson/redisson/3.4.3/org/redisson/api/RReadWriteLock.html) Java对象实现了`java.util.concurrent.locks.ReadWriteLock`接口。其中读锁和写锁都继承了[RLock](https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器#81-可重入锁reentrant-lock)接口。

分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。

```java
RReadWriteLock rwlock = redisson.getReadWriteLock("anyRWLock");
// 最常见的使用方法
rwlock.readLock().lock();
// 或
rwlock.writeLock().lock();
```

大家都知道，如果负责储存这个分布式锁的Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改[Config.lockWatchdogTimeout](https://github.com/redisson/redisson/wiki/2.-配置方法#lockwatchdogtimeout监控锁的看门狗超时单位毫秒)来另行指定。

另外Redisson还通过加锁的方法提供了`leaseTime`的参数来指定加锁的时间。超过这个时间后锁便自动解开了。

```java
// 10秒钟以后自动解锁
// 无需调用unlock方法手动解锁
rwlock.readLock().lock(10, TimeUnit.SECONDS);
// 或
rwlock.writeLock().lock(10, TimeUnit.SECONDS);

// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);
// 或
boolean res = rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);
...
lock.unlock();
```





##  闭锁（CountDownLatch）

当 gogogo这个方法被调用5次后，lockDoor运行

![image-20201207143550381](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201207143557.png)



## 信号量



总共只有



基于Redis的Redisson的分布式信号量（[Semaphore](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html)）Java对象`RSemaphore`采用了与`java.util.concurrent.Semaphore`相似的接口和用法。同时还提供了[异步（Async）](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreAsync.html)、[反射式（Reactive）](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreReactive.html)和[RxJava2标准](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreRx.html)的接口。

```java
RSemaphore semaphore = redisson.getSemaphore("semaphore");
semaphore.acquire();
//或
semaphore.acquireAsync();
semaphore.acquire(23);
semaphore.tryAcquire();
//或
semaphore.tryAcquireAsync();
semaphore.tryAcquire(23, TimeUnit.SECONDS);
//或
semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);
semaphore.release(10);
semaphore.release();
//或
semaphore.releaseAsync();
```





## 使用redisson分布式加锁

![image-20201207145436266](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201207145436.png)

# redis缓存数据一致性



1.双写模式
		2.失效模式



![image-20201207145536763](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201207145536.png)

![image-20201207145552788](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201207145552.png)

![image-20201207150438274](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201207150438.png)





# spring cache

## 使用

### 依赖

```java
<!--使用spring cache-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```



### 配置

> CacheAutoConfiguration
>    
> 		RedisCacheConfiguration
>    	 													
> 		RedisCacheManager
> 主要配置都在CacheProperties中

~~~yml
spring:
	cache:
    	type: redis
~~~



### 使用

![image-20201209123504471](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209123504.png)

第一次

![image-20201209131115033](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209131115.png)

![image-20201209131135035](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209131135.png)

第二次，没有调用这个方法

![image-20201209131153152](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209131153.png)

## 常用注解

```java
@EnableCaching 在配置类上添加配置，开启缓存
```

- `@Cacheable`: Triggers cache population.

  - 触发将会把数据保存到缓存中

- `@CacheEvict`: Triggers cache eviction.

  - 触发将会把数据从缓存中删除

- `@CachePut`: Updates the cache without interfering with the method execution.

  - 不影响方法执行，更新缓存

- `@Caching`: Regroups multiple cache operations to be applied on a method.

  - 组合以上多个操作

    ```java
    @Caching(cacheable = {
            @Cacheable(value = {"cache1"},key = "#root.method.name"),
            @Cacheable(value = {"cache2"},key = "#root.method.name")
    }, evict = {
            @CacheEvict(value = {"evict1"},key ="#root.method.name" )
            }
    )
    ```

- `@CacheConfig`: Shares some common cache-related settings at class-level.

  - 在类级别共享缓存的相同配置



## 默认行为

1. 如果缓存命中，方法不掉用
2. ==key默认自动生成，缓存指定的value::simpleKey[]自动生成的key值==
3. ==缓存的value的值，默认实现jdk序列化机制，将序列化后的数据存到redis==
4. ==过期时间TTL是-1，永不过期==



> 自定义

1. 指定缓存使用的key

   ![image-20201209132602884](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209132602.png)

   ![image-20201209132939043](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209132939.png)

2. 指定缓存的ttl时间

   可以使用spel表达式

   ![image-20201209132612885](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201209132612.png)

3. 指定缓存数据为json格式





## 抽取配置类 

```java
@Configuration
@EnableCaching
@EnableConfigurationProperties(CacheProperties.class)  // 读取配置文件中的配置
public class CacheConfig {

    /**
     * 配置文件中的配置没有用上
     *
     * @return {@link RedisCacheConfiguration}
     */
    @Bean
    public RedisCacheConfiguration  redisCacheConfiguration() {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        // 序列化机制：使用json格式缓存
        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.json()));
        // 设置ttl时间
        config = config.entryTtl(Duration.ofDays(1));
        // 默认缓存空值，设置为不缓存空值
//        config = config.disableCachingNullValues();
        return config;
    }
}
```



## 不足

### 读模式

1. 缓存穿透：

   ```java
   查询一个null数据，解决：缓存空数据，
   config = config.disableCachingNullValues();
   ```

2. 缓存击穿

   ~~~java
   大量并发进来同时查一个数据，且这个数据刚好失效：解决加锁 
   默认是没有加锁的
   ~~~

3. 缓存雪崩

   ~~~java
   大量的key同时过期，解决：加随机时间（直接指定过期时间即可）
   ~~~

### 写模式

缓存一致性

1. 读写的加锁，有序进行（读多写少的系统）
2. 引入canal，感知到mysql的更新操作
3. 读多写少，直接去数据库中查询就可以







### 总结

1. 常规数据可以使用spring cache(读多写少，即时性，一致性要求不高的数据)来可以使用
2. 特殊数据：特殊设计





# 商城搜索页-检索服务 

## 搜索已经上架商品的信息



根据用户输入条件进行检索

![image-20201210121550188](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201210121557.png)



### 检索条件分析

```java
封装页面所有可能传递过来的查询条件
 1.全文检索：skuTitle -> keyword
 2.排序：saleCount，hotScore，skuPrice
 3.过滤：hasStock，skuPrice，brandID，catalog3Id,attrs
 4.聚合：attrs
```

```java
public class SearchParam {

    /**
     * 关键字,页面传过来的全为匹配字段(skuTitle)
     */
    private String keyword;

    /**
     * 三级分类 id
     */
    private Long catalog3Id;

    /**
     * 排序条件
     * saleCount，hotScore，skuPrice
     * saleCount_desc or saleCount_asc
     */
    private String sort;

    /**
     * 是否只显示有货
     */
    private Integer hasStock;

    /**
     * sku价格
     */
    private String skuPrice;

    /**
     * 品牌Id列表
     */
    private List<Long> brandId;

    /**
     * 属性 attrs=1_其他:安卓&attrs=2_六寸:五寸:七寸
     * 属性id_属性值:属性值
     */
    private List<String> attrs;

    /**
     * 页面号
     */
    private Integer pageNum;
}
```



### 返回页面的数据

```java
@Data
public class SearchResData {

    /**
     * 查询到的所有的商品信息
     */
    private List<SkuEsModel> products;

    /**
     * 页面号
     */
    private Integer pageNum;

    /**
     * 总共有多少条数据
     */
    private Long total;

    /**
     * 总页数
     */
    private Integer totalPage;

    /**
     * 当前结果查询到的所有品牌
     */
    private List<BrandVo> brands;

    /**
     * 当前结果查询到的所有属性
     */
    private List<AttrVo> attrs;
    /**
     * 当前结果查询到的所有分类信息
     */
    private List<CatalogVo> catalogs;


    @Data
    public static class BrandVo{
        private Long brandId;
        private String brandName;
        private String brandImg;
    }

    @Data
    public static class AttrVo{
        private Long attrId;
        private String attrName;
        private List<String> attrValues;
    }


    @Data
    public static class CatalogVo{
        private Long catalogId;
        private String catalogName;
    }
}
```



### 接口实现

```java
@Controller
public class SearchController {

    @Autowired
    private MallSearchService mallSearchService;

    /**
     * 在es中搜索已经上架商品的信息
     *
     * @param param 参数
     * @param model 模型
     * @return {@link String}* @throws IOException ioexception
     */
    @GetMapping("/list.html")
    public String list(SearchParam param, Model model) throws IOException {
        SearchResData data = mallSearchService.search(param);
        model.addAttribute("result", data);
        return "list";
    }
}
```





### 业务方法

```java
@Service
public class MallSearchServiceImpl implements MallSearchService {

    @Resource
    private RestHighLevelClient esClient;

    @Override
    public SearchResData search(SearchParam param) throws IOException {


        // 1.准备检索请求
        SearchRequest searchRequest = buildSearchConditions(param);
        // 2.执行检索
        SearchResponse response = esClient.search(searchRequest, RequestOptions.DEFAULT);

        // 3.封装对象
        return getData(response, param);
    }

    /**
     * 构建搜索条件
     *
     * @param param 参数
     * @return {@link SearchRequest}
     */
    private SearchRequest buildSearchConditions(SearchParam param) {

        // 构建dsl查询语句
        SearchSourceBuilder searchSource = SearchSourceBuilder.searchSource();

        // 1.构建boolQuery
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();

        // 2.must keyword
        if (StringUtils.isNoneBlank(param.getKeyword())) {
            boolQuery.must(QueryBuilders.matchQuery("skuTitle", param.getKeyword()));
        }

        // 3.filter 过滤
        // 三级分类id
        if (param.getCatalog3Id() != null) {
            boolQuery.filter(QueryBuilders.matchQuery("catalogId", param.getCatalog3Id()));
        }
        // 品牌id
        if (param.getBrandId() != null && param.getBrandId().size() > 0) {
            boolQuery.filter(QueryBuilders.termsQuery("brandId", param.getBrandId()));
        }
        // 查询是否有库存
        if (param.getHasStock() != null) {
            boolQuery.filter(QueryBuilders.termsQuery("hasStock", param.getHasStock() == 1));
        }
        // 价格区间
        if (StringUtils.isNoneBlank(param.getSkuPrice())) {
            // 1_500 _500 500_
            String[] s = param.getSkuPrice().split("_");
            RangeQueryBuilder query = QueryBuilders.rangeQuery("skuPrice");
            if (s.length == 2) {
                query.gte(s[0]).lte(s[1]);
            } else if (s.length == 1) {
                if (param.getSkuPrice().startsWith("_")) {
                    query.lte(s[0]);
                } else if (param.getSkuPrice().endsWith("_")) {
                    query.gte(s[0]);
                }
            }
            boolQuery.filter(query);
        }
        // 属性
        if (param.getAttrs() != null && param.getAttrs().size() > 0) {
            for (String attrStr : param.getAttrs()) { // attrs=1_其他:安卓&attrs=2_六寸:五寸:七寸  属性id_属性值:属性值
                BoolQueryBuilder bool = QueryBuilders.boolQuery();

                String[] s = attrStr.split("_");
                // 获取需要查询的属性的信息
                String attrId = s[0];
                String[] attrValues = s[1].split(":");

                bool.must(QueryBuilders.matchQuery("attrs.attrId", attrId));
                bool.must(QueryBuilders.termsQuery("attrs.attrName", attrValues));

                NestedQueryBuilder nestedQueryBuilder = QueryBuilders.nestedQuery("attrs", bool, ScoreMode.None);
                boolQuery.filter(nestedQueryBuilder);
            }
        }

        // 4.排序
        if (StringUtils.isNoneBlank(param.getSort())) { // saleCount，hotScore，skuPrice  saleCount_desc or saleCount_asc
            String[] s = param.getSort().split("_");
            String field = s[0];
            String sort = s[1];

            // 构建排序条件
            SortOrder sortOrder = SortOrder.ASC;
            if (sort.equals("desc"))
                sortOrder = SortOrder.DESC;
            searchSource.sort(field, sortOrder);
        }

        // 5.分页
        searchSource.size(PRODUCT_PAGE_SIZE)
                .from((param.getPageNum() - 1) * PRODUCT_PAGE_SIZE);

        // 6.高亮
        if (StringUtils.isNoneBlank(param.getKeyword())) {
            searchSource.highlighter(SearchSourceBuilder.highlight()
                    .field("skuTitle")
                    .preTags("<b style='color:red'>").postTags("</b>"));
        }

        // 7.聚合分析
        TermsAggregationBuilder brandAgg = AggregationBuilders.terms("brandAgg").field("brandId").size(50);  // 找出每一个品牌的id
        brandAgg.subAggregation(AggregationBuilders.terms("brandNameAgg").field("brandName").size(1));      // 名字
        brandAgg.subAggregation(AggregationBuilders.terms("brandImgAgg").field("brandImg").size(1));       // 图片
        searchSource.aggregation(brandAgg);

        TermsAggregationBuilder catalogAgg = AggregationBuilders.terms("catalogAgg").field("catalogId").size(50);  // 找出每一个分类的id
        catalogAgg.subAggregation(AggregationBuilders.terms("catalogNameAgg").field("catalogName").size(1));      // 名字
        catalogAgg.subAggregation(AggregationBuilders.terms("catalogImgAgg").field("catalogImg").size(1));       //  图片
        searchSource.aggregation(catalogAgg);

        NestedAggregationBuilder attrAgg = AggregationBuilders.nested("attrAgg", "attrs");          // 找出属性的相关信息
        AggregationBuilder attrIdAgg = AggregationBuilders.terms("attrIdAgg").field("attrs.attrId");
        attrIdAgg.subAggregation(AggregationBuilders.terms("attrNameAgg").field("attrs.attrName"));
        attrIdAgg.subAggregation(AggregationBuilders.terms("attrValueAgg").field("attrs.attrValue"));
        attrAgg.subAggregation(attrIdAgg);
        searchSource.aggregation(attrAgg);


        searchSource.query(boolQuery);

        return new SearchRequest().source(searchSource).indices(EsConstant.PRODUCT_INDEX);
    }

    /**
     * 返回页面需要的数据
     *
     * @param response 响应
     * @param param
     * @return {@link SearchResData}
     */
    private SearchResData getData(SearchResponse response, SearchParam param) {
        SearchResData data = new SearchResData();

        // 准备数据
        // 封装product需要的数据
        SearchHits hits = response.getHits();
        SearchHit[] hitsHits = hits.getHits();
        // 封装其他需要的数据
        Aggregations aggregations = response.getAggregations();

        List<SkuEsModel> skuEsModels = new ArrayList<>();
        List<SearchResData.BrandVo> brandVos = new ArrayList<>();
        List<SearchResData.AttrVo> attrVos = new ArrayList<>();
        List<SearchResData.CatalogVo> catalogVos = new ArrayList<>();

        // 设置产品总信息
        for (SearchHit h : hitsHits) {
            Map<String, Object> source = h.getSourceAsMap();
            SkuEsModel skuEsModel = BeanUtil.mapToBean(source, SkuEsModel.class, true);

            // 设置高亮
            if (StringUtils.isNotBlank(param.getKeyword())) {
                skuEsModel.setSkuTitle(String.valueOf(h.getHighlightFields().get("skuTitle")));
            }
            skuEsModels.add(skuEsModel);
        }

        // 设置分类
        ParsedLongTerms catalogAgg = aggregations.get("catalogAgg");
        for (Terms.Bucket bucket : catalogAgg.getBuckets()) {
            SearchResData.CatalogVo catalogVo = new SearchResData.CatalogVo();
            ParsedStringTerms catalogNameAgg = bucket.getAggregations().get("catalogNameAgg");

            catalogVo.setCatalogId((Long) bucket.getKey());
            catalogVo.setCatalogName(catalogNameAgg.getBuckets().get(0).getKeyAsString());

            catalogVos.add(catalogVo);
        }

        // 设置品牌
        ParsedLongTerms brandAgg = aggregations.get("brandAgg");
        for (Terms.Bucket bucket : brandAgg.getBuckets()) {
            SearchResData.BrandVo brandVo = new SearchResData.BrandVo();
            ParsedStringTerms brandImgAgg = bucket.getAggregations().get("brandImgAgg");
            ParsedStringTerms brandNameAgg = bucket.getAggregations().get("brandNameAgg");

            brandVo.setBrandId((Long) bucket.getKeyAsNumber());
            brandVo.setBrandImg(brandImgAgg.getBuckets().get(0).getKeyAsString());
            brandVo.setBrandName(brandNameAgg.getBuckets().get(0).getKeyAsString());

            brandVos.add(brandVo);
        }

        // 设置属性
        ParsedNested attrAgg = aggregations.get("attrAgg");
        ParsedLongTerms attrIdAgg = attrAgg.getAggregations().get("attrIdAgg");

        for (Terms.Bucket bucket : attrIdAgg.getBuckets()) {
            SearchResData.AttrVo attrVo = new SearchResData.AttrVo();
            ParsedStringTerms attrNameAgg = bucket.getAggregations().get("attrNameAgg");
            ParsedStringTerms attrValueAgg = bucket.getAggregations().get("attrValueAgg");

            attrVo.setAttrId((Long) bucket.getKey());
            attrVo.setAttrName(attrNameAgg.getBuckets().get(0).getKeyAsString());
            attrVo.setAttrValue(attrValueAgg.getBuckets().stream().map(MultiBucketsAggregation.Bucket::getKeyAsString).collect(Collectors.toList()));

            attrVos.add(attrVo);
        }

        data.setProducts(skuEsModels);
        data.setBrands(brandVos);
        data.setAttrs(attrVos);
        data.setCatalogs(catalogVos);

        data.setPageNum(param.getPageNum());
        data.setTotal(hits.getTotalHits().value);
        data.setTotalPage(Math.toIntExact(
                hits.getTotalHits().value % PRODUCT_PAGE_SIZE == 0
                ? hits.getTotalHits().value / PRODUCT_PAGE_SIZE
                : (hits.getTotalHits().value / PRODUCT_PAGE_SIZE) + 1));

        return data;
    }
}
```







## 添加面包屑导航功能



```
SearchParam
```

![image-20201211180202917](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211180210.png)

```
SearchResData
```

![image-20201211180220808](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211180220.png)

![image-20201211180246923](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211180247.png)



业务方法

```java
if (param.getAttrs() != null && param.getAttrs().size() > 0) {

    List<SearchResData.NavVo> navVos = param.getAttrs().stream().map(i -> {
        // 分析每个attrs传过来查询的数值；
        SearchResData.NavVo navVo = new SearchResData.NavVo();
        String[] s = i.split("_");
        navVo.setNavValue(s[1]);

        R r = productServiceFeign.attrInfo(Long.valueOf(s[0]));
        if (r.getCode() == 0) {
            AttrRespVo attr = (AttrRespVo) r.get("attr");

            navVo.setNavName(attr.getAttrName());
        }

        // 取消这个面包屑后，我们要跳转到哪个地方，将请求地址置空
        String replace = param.get_queryString().replace("attrs=" + Arrays.toString(s), "");
        navVo.setLink("http://localhost:8889/list.html?" + replace);

        return navVo;
    }).collect(Collectors.toList());

    data.setNavs(navVos);
}
```



# 异步编排

completableFuture



![image-20201212163441946](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212163449.png)



## 启动异步编排任务

```java
public class ThreadTest {

    static ExecutorService executor = new ThreadPoolExecutor(10, 100 * 100, 10L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(), Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy());

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start");
        // 沒有返回值
        CompletableFuture<Void> voidThread = CompletableFuture.runAsync(() -> {
            System.out.println("当前线程" + Thread.currentThread().getName());
            int i = 10 / 2;
            System.out.println("结果:" + i);
        }, executor);
		
        // 有返回值
        CompletableFuture<Integer> intThread = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程" + Thread.currentThread().getName());
            return 100 / 2;
        }, executor);
        System.out.println("结果"+intThread.get());
        System.out.println("main-end");
    }
}
```





## 任务完成时回调方法

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    System.out.println("main-start");
    CompletableFuture<Integer> fu = CompletableFuture
            .supplyAsync(() -> 10, executor)
            // 当上面的任务完成后调用
            .whenComplete((res, ex) -> System.out.println(res))
            // 出现异常后
            .exceptionally(ex-> 100);
    System.out.println(fu.get());
    System.out.println("main-end");
}
```

![image-20201212165924797](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212165925.png)



## 任务完成后对结果进行修改

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    System.out.println("main-start");

    CompletableFuture<Integer> handle = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("开始执行业务");

                System.out.println("执行完毕");
                return 10;
            }, executor)
            .handle((res, e) -> {
                res = 20;
                return res;
            });
    System.out.println(handle.get());
    
    System.out.println("main-end");
}
```





## 线程串行化

![image-20201212170407279](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212170407.png)



## 两个任务组合-都要完成

![image-20201212171045226](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212171045.png)![image-20201212171054033](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212171054.png)

![image-20201212171058716](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212171058.png)





## 商品详情页

```java
@Override
public SkuItemVo item(Long skuId) {
    SkuItemVo res = new SkuItemVo();
    // 1.sku基本信息
    SkuInfoEntity skuInfo = getById(skuId);
    res.setSkuInfoEntity(skuInfo);

    Long spuId = skuInfo.getSpuId();
    Long catalogId = skuInfo.getCatalogId();

    // 2.sku的图片信息
    List<SkuImagesEntity> images = skuImagesService.getBySkuId(skuId);
    res.setImages(images);

    // 3.spu的销售属性
    List<SkuItemSaleAttrVo> saleAttrVo =  skuSaleAttrValueService.getSpuId(skuId);
    res.setSaleAttrs(saleAttrVo);

    // 4.spu的介绍
    SpuInfoDescEntity desc = spuInfoDescService.getById(spuId);
    res.setDesc(desc);

    // 5.spu的规格参数
    List<SpuItemAttrGroupVo> groupVos = attrGroupService.getBySpuId(spuId,catalogId);
    res.setGroupAttrs(groupVos);
    return res;
}
```



## 异步编排后



### 引入配置提示jar包

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
</dependency>
```

### 配置资源类

```java
@ConfigurationProperties(prefix = "thread.pool")
@Component
@Data
public class ThreadPoolConfigProperties {

    private Integer coreSize;
    private Integer maxSize;
    private Integer keepAlive;
}
```





### 配置类

```java
@Configuration
public class ThreadConfig {
    @Bean
    public ThreadPoolExecutor threadPool(ThreadPoolConfigProperties poolConfig) {
        return new ThreadPoolExecutor(poolConfig.getCoreSize(), poolConfig.getMaxSize(), poolConfig.getKeepAlive(), TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(10000), Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
    }
}
```





### 配置

![image-20201212215821566](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212215828.png)



### 异步编排后

```java
@Autowired
ThreadPoolExecutor threadPool;

@Override
public SkuItemVo item(Long skuId) {
    SkuItemVo res = new SkuItemVo();
    AtomicReference<Long> spuId = new AtomicReference<>();
    AtomicReference<Long> catalogId = new AtomicReference<>();

    CompletableFuture<SkuInfoEntity> skuInfoFuture = CompletableFuture.supplyAsync(() -> {
        // 1.sku基本信息
        SkuInfoEntity skuInfo = getById(skuId);
        res.setSkuInfoEntity(skuInfo);

        spuId.set(skuInfo.getSpuId());
        catalogId.set(skuInfo.getCatalogId());
        return skuInfo;
    }, threadPool);

    CompletableFuture<Void> spuSaleFuture = skuInfoFuture.thenAcceptAsync((r) -> {
        // 3.spu的销售属性
        List<SkuItemSaleAttrVo> saleAttrVo = skuSaleAttrValueService.getSpuId(skuId);
        res.setSaleAttrs(saleAttrVo);
    }, threadPool);

    CompletableFuture<Void> spuDescFuture = skuInfoFuture.thenAcceptAsync((r) -> {
        // 4.spu的介绍
        SpuInfoDescEntity desc = spuInfoDescService.getById(spuId);
        res.setDesc(desc);
    }, threadPool);

    CompletableFuture<Void> spuAttrFuture = skuInfoFuture.thenAcceptAsync((r) -> {
        // 5.spu的规格参数
        List<SpuItemAttrGroupVo> groupVos = attrGroupService.getBySpuId(spuId.get(), catalogId.get());
        res.setGroupAttrs(groupVos);
    }, threadPool);

    CompletableFuture<Void> imagesFuture = CompletableFuture.runAsync(() -> {
        // 2.sku的图片信息
        List<SkuImagesEntity> images = skuImagesService.getBySkuId(skuId);
        res.setImages(images);
    }, threadPool);

    try {
        CompletableFuture.allOf(imagesFuture, skuInfoFuture, spuAttrFuture, spuDescFuture, spuSaleFuture).get();
    } catch (Exception e) {
        e.printStackTrace();
    }

    return res;
}
```



# 认证服务

## 环境搭建

![image-20201214182524197](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214182531.png)

![image-20201214182832361](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214182832.png)

![image-20201214183051014](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214183051.png)



## 发送手机验证码

```html
<script type="text/javascript" charset="utf-8">
$(function () {
    $("#sendCode").click(function () {
        // 1.给指定手机发送验证码
        // 2.倒计时 60s
        if ($(this).hasClass("disabled")) {

        } else {
            timeoutChangeStyle();
        }
    });
})

var num = 10;

function timeoutChangeStyle() {
    $("#sendCode").attr("class", "disabled")
    var str = num + "s后再次发送"
    if (num === 0) {
        str = "发送验证码";
        num = 10;
        $("#sendCode").attr("class", "");
    } else {
        // 1.给指定手机发送验证码

                $.get("/sms/sendSms?mobile="+$("#mobile").val())
                // 2.倒计时 60s
                timeoutChangeStyle();
    }
    $("#sendCode").text(str);
    num--
}
</script>

  <a id="sendCode">发送验证码</a>
```



```java
@RestController
public class LoginController {

    @Autowired
    private SmsFeignService smsFeignService;
    @Autowired
    private StringRedisTemplate redisTemplate;

    @GetMapping("/sms/sendSms")
    public R sendSms(@RequestParam("mobile") String mobile) {
        // 1.接口防刷
        String s = redisTemplate.opsForValue().get(AutoConstant.SMS_CODE_CACHE_PREFIX + mobile);

        // 60s内不能在次发送
        if (s != null && System.currentTimeMillis() - Long.parseLong(s.split("_")[1]) < 60000) {
            return R.error();
        }

        // 生成验证码
        String code = UUID.randomUUID().toString().substring(0, 5) + "_" + System.currentTimeMillis();

        // 2.验证码再次校验  sms:code:13789983260,12345   10min有效期
        redisTemplate.opsForValue().set(AutoConstant.SMS_CODE_CACHE_PREFIX + mobile, code, 10, TimeUnit.MINUTES);
        return smsFeignService.sendSms(mobile, code.substring(0, 5));
    }

}
```



```java
@RestController
@RequestMapping("/sms")
public class SmsController {
    @Autowired
    private Sms sms;

    /**
     * 发送短信验证码
     *
     * @param mobile 移动
     * @param code   代码
     * @return {@link R}
     */
    @GetMapping("/sendSms")
    public R sendSms(@RequestParam("mobile") String mobile,@RequestParam("code")  String code) {
        sms.sendSms(mobile, code);
        return R.ok();
    }
}
```



```java
@Component
public class Sms {
    public  void sendSms(String mobile, String code) {
        String host = "http://dingxin.market.alicloudapi.com";
        String path = "/dx/sendSms";
        String method = "POST";
        String appcode = "25429856ccf4401eb7260bceb3fa65d9";
        Map<String, String> headers = new HashMap<String, String>();
        //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
        headers.put("Authorization", "APPCODE " + appcode);
        Map<String, String> querys = new HashMap<String, String>();
        querys.put("mobile", mobile);
        querys.put("param", "code:" + code);
        querys.put("tpl_id", "TP1711063");
        Map<String, String> bodys = new HashMap<String, String>();

        try {
            HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);
            System.out.println(response.toString());
            //获取response的body
            //System.out.println(EntityUtils.toString(response.getEntity()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



## 请求和页面的相互映射

``` java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        /**
         * 去登录页面
         *
         *  @GetMapping("/login.html")
         *  public String loginHtml () {
         *  return "login";
         *}
         */
        registry.addViewController("/login.html").setViewName("login");
        registry.addViewController("/reg.html").setViewName("reg");
    }
}
```







## 用户注册功能



### 认证服务注册接口

```java
/**
 * 注册用户
 *
 * @return {@link String}
 */
@PostMapping("/register")
public String register(@Valid UserRegisterVo vo, BindingResult result) {
    String goUrl = "redirect:/login.html";

    if (result.hasErrors()) {
        goUrl = "redirect:http://localhost:7777/reg.html";
    } else {
        // 1.校验验证码
        String code = vo.getCode();
        String mobile = vo.getMobile();
        String redisCode = redisTemplate.opsForValue().get(AutoConstant.SMS_CODE_CACHE_PREFIX + mobile);
        if (StringUtils.isNoneBlank(redisCode) && code.equals(redisCode)) {
            goUrl = "redirect:http://localhost:7777/reg.html";
        }else {
            // 2.验证码正确
            redisTemplate.delete(AutoConstant.SMS_CODE_CACHE_PREFIX + mobile);      // 删除验证码
            // 3.调用用户服务保存用户信息
            memberFeignService.register(vo);
        }
    }
    // 重定向到登录页面
    return goUrl;
}
```



### 远程调用用户服务注册用户

```java
/**
 * 注册
 *
 * @return {@link R}
 */
@PostMapping("/register")
public R register(@RequestBody UserRegisterVo vo) {
    try {
        memberService.register(vo);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return R.ok();
}

@Override
public void register(UserRegisterVo vo) {
    // 检查用户是否唯一
    checkMobile(vo.getMobile());
    checkUsername(vo.getUsername());

    // 保存
    MemberEntity memberEntity = MemberEntity.builder()
        .username(vo.getUsername())
        .password(vo.getPassword())
        .mobile(vo.getMobile())
        .levelId(1L)
        .build();
    save(memberEntity);
}

@Override
public boolean checkMobile(String mobile) {
    getEnt(mobile, "mobile");
    return true;
}

public void getEnt(String check, String field) {
    MemberEntity one = getOne(new QueryWrapper<MemberEntity>().eq(field, check));
    if (one != null) {
        throw new UserInfoExistException(one);
    }
}

public class UserInfoExistException extends RuntimeException {
    public UserInfoExistException(MemberEntity member) {
        super(check(member));
    }

    public static String check(MemberEntity member) {
        String res = "";
        if (member.getUsername() != null) {
            res = "用户名已经存在";
        } else if (member.getMobile() != null) {
            res = "手机号码已经存在";
        } else if (member.getEmail() != null) {
            res = "邮箱已经存在";
        }
        return res;
    }
}



@Data
public class UserRegisterVo {

    @NotEmpty(message = "用户名不能为空")
    @Length(min = 6,max = 18,message = "用户名必须在6-18位之间")
    private String username;
    @NotEmpty(message = "密码不能为空")
    @Length(min = 6,max = 18,message = "密码必须在6-18位之间")
    private String password;
    @NotEmpty(message = "手机号不能为空")
    @Pattern(regexp = "^[1][0-9]{10}$",message = "手机号格式不正确")
    private String mobile;
    @NotEmpty(message = "验证码不能为空")
    private String code;
}

```





### 密码加密

![image-20201216175102764](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216175102.png)

![image-20201216180958966](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216180959.png)







### 功能测试

![image-20201216182555045](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216182555.png)

![image-20201216182602945](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216182603.png)





![image-20201216185127008](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216185127.png)

![image-20201216185133376](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216185133.png)

![image-20201216185138590](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216185138.png)







## 用户登录



```java
@PostMapping("/login")
public String login(UserLoginVo vo) {

    // 远程
    R login = memberFeignService.login(vo);
    if (login.getCode() != 0) {
        return "redirect:/login.html";
    }
    return  "redirect:http://localhost:12000";
}
```



![image-20201216192041495](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216192041.png)



```java
@PostMapping("/login")
public R login(@RequestBody UserLoginVo vo) {
    MemberEntity member = memberService.login(vo);
    if (member == null) {
        return R.error("登录失败");
    }
    return R.ok();
}



@Override
public MemberEntity login(UserLoginVo vo) {
    String loginName = vo.getLoginName();
    String rawPasswd = vo.getPassword();
    MemberEntity dbMember = getOne(new QueryWrapper<MemberEntity>()
                                   .eq("username", loginName)
                                   .or()
                                   .eq("mobile", loginName)
                                   .or()
                                   .eq("email", loginName)
                                  );
    if (dbMember != null) {
        // 密码匹配
        String encryptedPassword = dbMember.getPassword();
        if (new BCryptPasswordEncoder().matches(rawPasswd, encryptedPassword)) {
            return dbMember;
        }
    }
    return null;
}
```





## 社交登录

### OAuth2.0

![image-20201217185328812](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217185328.png)

todo

## 记录登录状态-分布式session

### 统一存储

![image-20201220182551399](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220182558.png)





```java
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```





![image-20201220184233085](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220184233.png)

![image-20201220184242243](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220184242.png)





![image-20201220185215550](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220185215.png)

![image-20201220185223964](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220185224.png)



### 修改问题

![image-20201220193702610](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220193702.png)

![image-20201220193716948](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220193717.png)

![image-20201220193730874](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220193730.png)

![image-20201220193748417](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220193748.png)





### 自定义session配置

```java
@Configuration
public class SessionConfig {

    @Bean
    public RedisSerializer<Object>redisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }

    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer cookie = new DefaultCookieSerializer();
        cookie.setDomainName("localhost"); // cookie作用域，由于我没有搭建域名服务器，所以localhost就可以了
        return cookie;
    }
}
```



 

### 原理

![image-20201221172059220](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221172059.png)



```java
@Override
public HttpSessionWrapper getSession(boolean create) {
   HttpSessionWrapper currentSession = getCurrentSession();
   if (currentSession != null) {
      return currentSession;
   }
   S requestedSession = getRequestedSession();
   if (requestedSession != null) {
      if (getAttribute(INVALID_SESSION_ID_ATTR) == null) {
         requestedSession.setLastAccessedTime(Instant.now());
         this.requestedSessionIdValid = true;
         currentSession = new HttpSessionWrapper(requestedSession, getServletContext());
         currentSession.markNotNew();
         setCurrentSession(currentSession);
         return currentSession;
      }
   }
   else {
      // This is an invalid session id. No need to ask again if
      // request.getSession is invoked for the duration of this request
      if (SESSION_LOGGER.isDebugEnabled()) {
         SESSION_LOGGER.debug(
               "No session found by id: Caching result for getSession(false) for this HttpServletRequest.");
      }
      setAttribute(INVALID_SESSION_ID_ATTR, "true");
   }
   if (!create) {
      return null;
   }
   if (SESSION_LOGGER.isDebugEnabled()) {
      SESSION_LOGGER.debug(
            "A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for "
                  + SESSION_LOGGER_NAME,
            new RuntimeException("For debugging purposes only (not an error)"));
   }
   S session = SessionRepositoryFilter.this.sessionRepository.createSession();
   session.setLastAccessedTime(Instant.now());
   currentSession = new HttpSessionWrapper(session, getServletContext());
   setCurrentSession(currentSession);
   return currentSession;
}
```







## 单点登录

1. 一处登录，处处登录。
2. 统一session的名字

todo







# 购物车

## 离线购物车

- 离线的时候保存着用户没有登录时的购物车信息
- 等用户登录后，离线购物车的内容自动合并到登录用户的购物车内
- 离线购物车清空



## vo封装

购物车的各个属性都需要计算	

```java
@Data
public class Cart {
    List<CartItem> items;
    private Integer countNum;           // 商品数量
    private Integer countType;         // 商品类型的个数
    private BigDecimal totalAmount;   // 当前购物车总价格
    private BigDecimal reduce = new BigDecimal(0);       // 优惠价格

    public Integer getCountNum() {
        int count = 0;
        if (items != null && items.size() > 0) {
            for (CartItem item : items) {
                count += item.getCount();
            }
        }
        setCountNum(count);
        return count;
    }

    public void setCountNum(Integer countNum) {
        this.countNum = countNum;
    }

    public Integer getCountType() {
        int count = 0;
        if (items != null && items.size() > 0) {
            for (CartItem item : items) {
                count += 1;
            }
        }
        setCountType(count);
        return countType;
    }

    public void setCountType(Integer countType) {
        this.countType = countType;
    }

    public BigDecimal getTotalAmount() {
        BigDecimal count = new BigDecimal(0);
        if (items != null && items.size() > 0) {
            for (CartItem item : items) {
                count = count.add(item.getTotalPrice();
            }
        }
        count = count.subtract(reduce);
        setTotalAmount(count);
        return totalAmount;
    }

    public void setTotalAmount(BigDecimal totalAmount) {
        this.totalAmount = totalAmount;
    }

    public BigDecimal getReduce() {
        return reduce;
    }

    public void setReduce(BigDecimal reduce) {
        this.reduce = reduce;
    }
}
```





```java
@Data
public class CartItem {

    private Long skuId;
    private Boolean check = true;
    private String title;
    private String image;
    private List<String> skuAttr;
    private BigDecimal price;
    private Integer count;
    private BigDecimal totalPrice;

    public BigDecimal getTotalPrice() {
        totalPrice = price.multiply(new BigDecimal(count));
        return totalPrice;
    }
}
```



## 拦截器判断用户是否登录(threadLocal)

1. 拦截器判断用户是否登录
2. 登录保存用户id
3. 没登录保存用户user-key
4. 保存用户信息，共享出去



### 拦截器

```java
@Component
public class CartInterceptor implements HandlerInterceptor {

    // 共享数据
    public static ThreadLocal<UserInfo> userInfoLocal = new ThreadLocal<>();

    /**
     * 方法执行前
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        UserInfo userInfo = new UserInfo();

        // 封装userInfo
        HttpSession session = request.getSession();
        MemberVo user = (MemberVo) session.getAttribute(AuthConstant.LOGIN_USER);
        if (user != null) {
            // 获取登录用户的购物车 -> userId
            userInfo.setUserId(user.getId());
        }
        // 获取离线购物车 -> user-key
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(CartConstant.User_COOKIE_NAME)) {
                    userInfo.setUserKey(cookie.getValue());
                    userInfo.setTemp(true);
                    break;
                }
            }
        }
        // 用户第一次登录分配一个随机的user-key
        if (StringUtils.isBlank(userInfo.getUserKey())) {
            userInfo.setUserKey(UUID.randomUUID().toString());
        }
        // 目标方法执行前
        userInfoLocal.set(userInfo);
        return true;
    }

    /**
     * 方法执行后
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        UserInfo userInfo = userInfoLocal.get();

        // 如果是false就表明是第一次
        if (!userInfo.isTemp()) {
            Cookie cookie = new Cookie(CartConstant.User_COOKIE_NAME, userInfo.getUserKey());
            cookie.setDomain("localhost");
            cookie.setMaxAge(CartConstant.COOKIE_TTL);
            response.addCookie(cookie);
        }
    }
}
```





### 注册拦截器

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 注册拦截器 -> 拦截所有请求
        registry.addInterceptor(new CartInterceptor()).addPathPatterns("/**");
    }
}
```









## 购物车功能(redis保存，异步编排)



### controller方法

```java
@GetMapping("/addToCart")
public String addToCart(@RequestParam String skuId, @RequestParam Integer num, Model model) throws ExecutionException, InterruptedException {
    CartItem cartItem = cartService.addToCart(skuId, num);
    model.addAttribute("item", cartItem);
    return "success";
}
```





### service

运用了线程池以及异步编排

```java
@Override
public CartItem addToCart(String skuId, Integer num) throws ExecutionException, InterruptedException {
    BoundHashOperations<String, Object, Object> ops = getCartOps();
    CartItem cartItem;
    
    // 判断这个商品在购物车中是否存在
    Object o = ops.get(JSON.toJSONString(skuId)); // fix 保存格式为json 所以读取格式也要是json
    if (Objects.isNull(o)) {
        cartItem = new CartItem();
        // 添加新商品：
        // 1.查询当前要添加的商品信息
        CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {
            R r = productFeignService.info(Long.parseLong(skuId));  // 远程调用
            SkuInfoEntity info = BeanUtil.toBean(r.get("skuInfo"), SkuInfoEntity.class);
            cartItem.setSkuId(info.getSkuId());
            cartItem.setCheck(true);
            cartItem.setTitle(info.getSkuTitle());
            cartItem.setImage(info.getSkuDefaultImg());
            cartItem.setPrice(info.getPrice());
            cartItem.setCount(num);
            cartItem.setTotalPrice(info.getPrice().multiply(new BigDecimal(num)));
        }, thread);
        // 2.查询属性信息
        CompletableFuture<Void> getAttrTask = CompletableFuture.runAsync(() -> {
            List<String> value = productFeignService.getSkuSaleAttrValue(skuId.toString());  // 远程调用
            cartItem.setSkuAttr(value);
        }, thread);
        
        CompletableFuture.allOf(getAttrTask, getSkuInfoTask).get();
    } else {
        // 1.修改数量
        cartItem = (CartItem) o;
        cartItem.setCount(cartItem.getCount() + num);
        cartItem.setTotalPrice(cartItem.getTotalPrice());
    }
    // 3.保存到redis中
    ops.put(JSON.toJSONString(skuId), cartItem);
    
    return cartItem;
}
```



获取购物车功能

```java
private static final String cart_prefix = "cart:";

/**
 * 获取购物车
 *
 * @return {@link BoundHashOperations<String, Object, Object>}
 */
private BoundHashOperations<String, Object, Object> getCartOps() {
    UserInfo user = CartInterceptor.userInfoLocal.get();

    // 1.生成redis中的key
    StringBuilder cartKey = new StringBuilder(cart_prefix);
    if (user.getUserId() != null) {
        cartKey.append(user.getUserId());
    } else {
        cartKey.append(user.getUserKey());
    }

    BoundHashOperations<String, Object, Object> ops = redisTemplate.boundHashOps(cartKey.toString());
    return ops;
}
```





### 功能测试

![image-20201224190631928](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201224190632.png)

![image-20201224190658760](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201224190658.png)



发送请求后：



![image-20201224190715301](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201224190715.png)

![image-20201224190727885](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201224190728.png)





## 解决页面刷新，再次发送请求的问题

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201224202924.png)

```java
@Override
public CartItem getCartItem(String skuId) {
    BoundHashOperations<String, Object, Object> ops = getCartOps();
    String s = (String) ops.get(JSON.toJSONString(skuId));
    return JSON.parseObject(s, new TypeReference<CartItem>() {});
}
```



![image-20201224203550749](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201224203550.png)



## 增加用户登录后合并购物车功能



```java
/**
 * 购物车列表
 * 浏览器有一个cookie：user-key，用来表示用户的身份
 * 登录：按session
 * 没有登录：user-key
 * 第一次：创建user-key
 *
 * @return {@link String}
 */
@GetMapping("/cartList.html")
public String cartList(Model model) throws ExecutionException, InterruptedException {
    // 获取当前登录用户的信息
    Cart cart = cartService.getCart();
    model.addAttribute("cart",cart);
    return "cartList";
}
```





```java
@Override
public Cart getCart() throws ExecutionException, InterruptedException {
    UserInfo user = CartInterceptor.userInfoLocal.get();
    Cart cart = new Cart();

    // 1.获取离线购物车
    List<CartItem> items = getCartItems(cart_prefix+user.getUserKey());
    // 判断离线购物车中是否有内容
    if (items != null && items.size() > 0) {
        // 2.获取登录购物车
        Long userId = user.getUserId();
        if (userId != null) {
            // 3.用戶已经登录->合并购物车->清空离线购物车
            for (CartItem cartItem : items) {
                addItemToCart(cartItem.getSkuId().toString(),cartItem.getCount());  // 合并购物车
            }
            deleteCart(cart_prefix+ user.getUserKey());  // 清空离线购物车
            items = getCartItems(cart_prefix + userId);   // 获取合并后的购物车内容
        }
    }
    cart.setItems(items);

    return cart;
}

/**
 * 删除购物车
 *
 * @param key user key
 */
private void deleteCart(String key) {
    redisTemplate.delete(key);
}

/**
 * 根据购物项的key,获取对应购物项
 *
 * @param key 关键
 * @return {@link List<CartItem>}
 */
private List<CartItem> getCartItems(String key) {
    BoundHashOperations<String, Object, Object> ops = redisTemplate.boundHashOps(key);
    List<Object> values = ops.values();
    if (values != null && values.size() > 0)
        return values.stream()
                .map(s -> (CartItem) s)
                .collect(Collectors.toList());
    return null;
}
```