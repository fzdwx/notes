#  树形结构

![image-20201215092652815](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215092700.png)



# 基本概念



- 节点、根节点、父节点、子节点、兄弟节点 
- 一棵树可以没有任何节点，称为`空树`
- 一颗树可以只有一个节点，也就是`根节点`
- 子树、左子树、右子树



- `节点的度:子树的个数`
- `树的度`：所有节点`度中的最大值`
- 叶子节点：度为0的节点
- 非叶子节点：度不是0的
- 层数：根节点在第一层，根节点的子节点在第二层，依次类推
- 节点的深度：从==根节点==到当==前节点==唯一路径上的节点总数
- 节点高度：==当前节点==到==最远叶子节点==的路径上的节点总数
- 树的深度：所有节点深度的最大值
- 树的高度：所有节点高度中的最大值

![image-20201215104822543](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215104822.png)

- 有序树：树中任意节点的子节点之间有顺序关系
- 无序树：树中任意节点的子节点直接没有顺序关系
- 森林：由m(m>=0)棵不相交的树组成的集合





# 二叉树

1. 每个节点的度最大为2(最大有2个子树)
2. 左子树和右子树是有顺序的
3. 非空二叉树的第`i`层，最多有`2^i-1`个节点(第几层有多少个节点)
4. 在层数为`h`的二叉树上最多有 `(2^h)-1`个节点
5. 对于一个二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则：n0 = n2 +1
   1. 假设度为1的节点个数为n1，则：n=n0+n1+n2
   2. 二叉树的边数T = n1+2*n2 = n-1 = n0 + n1 + n2-1



## **真二叉树**

所有节点的度要么都为0，要么为2

![image-20201215110258988](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215110259.png)

## **满二叉树**

所有节点的度要么都为0，要么为2。且所有的叶子节点都在最后一层

![image-20201215110224968](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215110225.png)

- 假设满二叉树的层数是h
  - 第i层的节点数量：2^(i-1)
  - 叶子节点数量：2^(h-1)
  - 总节点数量:n = (2^h)  - 1
  - 高度： log2 2(n + 1)





## **完全二叉树**

**从树的根节点，从上到下，从左到右依次填满节点形成的二叉树**

所有叶子节点只会出现在最后2层，且最后1层的叶子节点都靠左对齐

- 度为1的节点只有左子树
- 度为1的节点要么是1个，要么是0个
- 同样节点数量的二叉树，完全二叉树的高度是最小的
- 如果完全二叉树的层树是h
  - 至少有2^(h-1)个节点
  - 最多有(2^h)-1个节点

![image-20201215111913702](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215111913.png)

![image-20201215113159137](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215113159.png)





**公式总结**

![image-20201215114015251](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215114015.png)







# 二叉搜索树

任意一个左节点的值小于任意右节点



## 接口设计

![image-20201215120533406](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215120533.png)





## add()

```java
public void add(T element) {
    elementNotNullCheck(element);

    // 1.初始化条件
    Node<T> temp = this.root;                      // 遍历的元素
    Node<T> parent = this.root;                   // 插入元素的父节点
    int compare = 0;                             // 记录插入位置
    Node<T> curr = new Node<>(element, parent); // 需要插入的元素

    // 2.找到父节点，以及插入位置
    // 2.a.判断根节点是否为空
    if (temp != null) {
        // 2.b.存在根节点，查找当前节点的父节点  parent.left/right = curr
        while (temp != null) {
            compare = compare(element, temp.element);
            parent = temp;
            if (compare > 0) {
                temp = temp.right;
            } else if (compare < 0) {
                temp = temp.left;
            } else {
                return;
            }
        }
    } else {
        root = curr;
    }

    // 3.添加节点
    curr.parent = parent;
    if (compare > 0) {
        parent.right = curr;
    } else if (compare < 0) {
        parent.left = curr;
    }
    size++;

}
```



## compare()

在设置泛型的时候必须规定要实现Comparable

![image-20201215130805459](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215130805.png)

```java
/**
 * 比较
 *
 * @param element 需要添加的元素
 * @param compare 比较的对象
 * @return {@link Integer}
 * 返回0 表示相等         覆盖
 * 大于0 表示element大    右边
 * 小于0 表示compare大    左边
 */
private Integer compare(T element, T compare) {
    return element.compareTo(compare);
}
```





### 方法二

![image-20201216101222721](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216101229.png)



![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216101233.png)





## 二叉树遍历

![image-20201215114954341](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215114954.png)

![image-20201215115210407](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215115210.png)





### 前序遍历 pre order  traversal

根节点 =>，前序遍历`左`子树 => 前序遍历`右`子树

```java
/**
 * 前序遍历
 *
 * @return {@link List<T>}
 */
public List<T> preorderTraversal() {
    List<T> list = new ArrayList<>();
    preorderTraversal(root, list);
    return list;
}


private List<T> preorderTraversal(Node<T> root, List<T> list) {
    if (root == null) {
        return list;
    }
    // root 节点
    list.add(root.element);
    // 前序遍历 左子树
    preorderTraversal(root.left, list);
    // 前序遍历 右子树
    preorderTraversal(root.right, list);
    
    return list;
}
```





### 中序遍历 in order traversal

```java
public List<T> inorderTraversal() {
    List<T> list = new ArrayList<>();
    return inorderTraversal(root, list);
}

private List<T> inorderTraversal(Node<T> root, List<T> list) {
    if (root == null) {
        return list;
    }
    inorderTraversal(root.left,list);
    list.add(root.element);
    inorderTraversal(root.right,list);
    return list;
}
```





### 后序遍历 post order

```java
/**
 * 后序遍历
 *
 * @return {@link List<T>}
 */
public List<T> postorderTraversal() {
    List<T> list = new ArrayList<>();
    return postorderTraversal(root, list);
}

private List<T> postorderTraversal(Node<T> root, List<T> list) {
    if (root == null) {
        return list;
    }
    postorderTraversal(root.left,list);
    postorderTraversal(root.right,list);
    list.add(root.element);
    return list;
}
```



### 层序遍历

```java
/**
 * 层序遍历
 *
 * @return {@link List<T>}
 */
public List<T> levelOrderTraversal() {
    List<T> list = new ArrayList<>();

    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();
        list.add(poll.element);
        if (poll.left != null) {
            queue.offer(poll.left);
        }
        if (poll.right != null) {
            queue.offer(poll.right);
        }
    }
    return list;
}
```





### 使用访问者模式修改

1.添加一个接口，回调。

```java
public interface Visitor<T> {
    void visit(T element);
}
```





2.让使用者传入接口的实现，表明要用这个元素干什么

![image-20201216121342090](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216121342.png)





### 增强遍历接口 —— 随时停止

1.修改接口为抽象类，但是不能使用lambda表达式了

```java
public static abstract class Visitor<T> {
    /**
     * 访问
     * 返回false 继续遍历
     * 返回true 停止遍历
     *
     * @param element 元素
     * @return boolean
     */
    public abstract boolean visit(T element);

    public boolean continueTo = false;
}
```





2.修改实现

![image-20201216130514197](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216130514.png)



![image-20201216130531139](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216130531.png)





## 计算二叉树的高度

```java
public int height() {
    return height(root);
}

private int height(Node<T> root) {
    if (root == null) {
        return 0;
    }
    return Math.max(height(root.left),height(root.right)) + 1;
}
```



~~~java
public int height2() {
    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);
    int h = 0;  // 记录高度
    int levelSize = 1; // 记录当前层级元素剩余个数
    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();  // 当前层级元素出队
        levelSize --;
        if (poll.left != null) {
            queue.offer(poll.left);   // 把当前层级元素入队
        }
        if (poll.right != null) {
            queue.offer(poll.right);  // 把当前层级元素入队
        }
        if (le		velSize == 0) {        // 如果当前层级元素出队完毕
            levelSize = queue.size();
            h++;
        }
    }
    return h;
}
~~~





## 判断二叉树是否完全二叉树

![image-20201216140057538](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216140057.png)



~~~java
public boolean isComplete() {
    if (root == null) {
        return false;
    }
    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);
    boolean leaf = false;
    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();  // 当前层级元素出队

        if (leaf && !poll.isLeaf()) {  // 如果没有叶子节点
            return false;
        }
        if (poll.hasChildren()) { //如果当前节点有子节点
            queue.offer(poll.left);
            queue.offer(poll.right);
        } else if (poll.left == null && poll.right != null) {  // 如果没有左子节点但是有右子节点->不是
            return false;
        } else {
            leaf = true;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
        }

    }
    return true;
}
~~~

![image-20201216141553100](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216141553.png)





```java
public boolean isComplete2() {
    if (root == null) {
        return false;
    }
    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);
    boolean leaf = false;
    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();  // 当前层级元素出队
        if (leaf && !poll.isLeaf()) {
            return false;
        }
        if (poll.left != null) { // 入队
            queue.offer(poll.left);
        } else if (poll.right != null) { // 没有左子节点，但有右子节点 -> 不是
            return false;
        }
        if (poll.right != null) { // 入队
            queue.offer(poll.right);
        } else {  // 右子节点为空，则往后的节点都必须是叶子节点
            leaf = true;
        }
    }
    return true;
}
```





## 反转二叉树

```java
public class _226反转二叉树 {

    /**
     * 倒置的树
     * 使用前序遍历
     *
     * @param root 根
     * @return {@link TreeNode}
     */
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        // 交换
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        invertTree(root.left);
        invertTree(root.right);
        return root;
    }


    public TreeNode invertTree2(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode poll = queue.poll();
            // 交换
            TreeNode temp = poll.left;
            poll.left = poll.right;
            poll.right = temp;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }
        }
        return root;
    }
}
```



## 根据遍历结果重构二叉树

![image-20201217104819368](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217104826.png)









## 前驱节点

![image-20201217110433903](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217110434.png)



```java
public Node<T> predecessor(Node<T> node) {
    if (node == null) {
        return null;
    }
    Node<T> p = node.left;
    // 前驱节点在左子树中,left.right.right.right  ...
    if (p != null) {
        while (p.right != null) {
            p = p.right;
        }
        return p;
    }
    p = node;
    // 前驱节点在父节点的左父节点
    while (p.parent != null && p == p.parent.left) { // 父节点==null，当前节点是父节点的右节点
        p = p.parent;
    }
    return p.parent;
}
```



## 后继节点

![image-20201217113447664](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217113447.png)

```java
public Node<T> successor(Node<T> node) {
    if (node == null) {
        return null;
    }
    Node<T> p = node.right;
    // 后继节点在右子树中,right.left.left.left  ...
    if (p != null) {
        while (p.left != null) {
            p = p.left;
        }
        return p;
    }
    p = node;
    // 后继节点在父节点的右父节点
    while (p.parent != null && p == p.parent.right) { // 父节点==null，当前节点是父节点的左节点
        p = p.parent;
    }
    return p.parent;
}
```





## remove()

如果一个节点的度为2,那么他的前驱、后继节点的度只可能是0或1

### 思路

```java
1.删除叶子节点(n0)  - 直接删除
2.删除n1  - 用子节点代替原节点的位置 node.left/right.parent = node.parent
3.删除n2  先用前驱或后继节点覆盖原节点，然后删除对应的前驱或后继
```

### 实现

```java
/**
 * 删除
 *
 * @param node 节点
 */
private void remove(Node<T> node) {
    if (node == null) {
        return;
    }

    if (node.hasTwoChildren()) {        // n2
        Node<T> s = predecessor(node);   // 要删除节点的后继节点
        node.element = s.element;     // 删除当前节点(覆盖当前节点所保存的值)
        node = s;
    }

    //n1、n0
    Node<T> removeNext = node.left != null ? node.left : node.right;   // 判断要删除的节点是否有子节点
    if (removeNext != null) {                                         // n1
        removeNext.parent = node.parent;                             // removeNext -> node.parent
        if (node.parent == null) {                                  // 根节点
            root = removeNext;
        } else if (node == node.parent.left) {                    // node.parent.left/right -> removeNext
            node.parent.left = removeNext;
        } else {
            node.parent.right = removeNext;
        }
    } else if (node.parent == null) {  // n0且没有父节点 ->root
        root = null;
    } else {     // n0  直接删除
        if (node.parent.left == node) {
            node.parent.left = null;
        } else if (node.parent.right == node) {
            node.parent.right = null;
        }
    }

    size--;
}
```