#  十大排序基本概览



![image-20201228083811317](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201228083818.png)









# 冒泡排序



```java
 private void m() {
        for (int i = 0; i < array.length; i++) {
            for (int j = i; j < array.length; j++) {
                if (cmp(i, j) > 0) {
                    swap(i, j);
                }
            }
        }
    }
```







## 优化1- 判断当前数组是否是有序的

如果是有序的则直接退出 

```java
 private void m1() {
        for (int i = 0; i < array.length; i++) {
            boolean sorted = true;
            for (int j = i; j < array.length ; j++) {
                if (cmp(i, j) > 0) {
                    swap(i, j);
                    sorted = false;
                }
            }
            if (sorted) break;
        }
    }
```





## 优化2-记录最后一次交换的位置

如果尾部已经有序，记录最后一次交换的位置，减少比较的次数



```java
private static void m(Integer[] array) {
    for (int end = array.length - 1; end > 0; end--) {
        int index =1;
        for (int begin = 1; begin <= end; begin++) {
            if (array[begin] > array[begin - 1]) {
                int temp = array[begin];
                array[begin] = array[begin-1];
                array[begin-1] = temp;
                index =begin;
            }
        }
        end = index;
    }
}
```







# 选择排序

1. 从数组中找到最大的那个元素，与最后的元素交换位置	
   - 执行完一轮后，最后的就是最大的元素
2. 重复执行



```java
private static void m(Integer[] array) {
    for (int i = 0; i < array.length; i++) {
        int maxIndex = i;
        for (int j = i; j < array.length; j++) {
            // 找出最大的值 记录索引
            if (array[maxIndex] > array[j]) {
                maxIndex = j;
            }
        }
        // 执行完一轮后才交换
        int temp = array[maxIndex];
        array[maxIndex] = array[i];
        array[i] = temp;
    }
}
```





# 堆排序

可以认为是对选择排序的一种优化



1. 对数组进行原地建堆
2. 重复执行,直到size = 1
   1. 交换堆顶和尾元素
   2. size–
   3. 对0位置元素进行siftDown





```java
public class HeapSort<E> extends Sort<E> {

    private int heapSize;

    @Override
    protected E[] sort() {
        // 1.建堆
        heapSize = array.length;
        for (int i = (heapSize >> 1) - 1; i >= 0; i--) {
            siftDown(i);
        }
        while (heapSize > 1) {
            // 2.交换堆顶的堆尾的元素
            swap(0, --heapSize);
            // 3.恢复堆的性质
            siftDown(0);
        }

        return array;
    }

    private void siftDown(int index) {
        E e = array[index];
        int half = heapSize >> 1; // 第一个叶子节点的索引 = 非叶子节点的数量 index * 2 <= size || (index * 2) <= size - 1
        while (index < half) {  // 有子节点才进入
            // 找出最大的子节点
            int cIndex = (index << 1) + 1;
            E c = array[cIndex];
            int crIndex = cIndex + 1;
            if (crIndex < heapSize && cmp(array[crIndex], c) > 0) {
                c = array[cIndex = crIndex];
            }

            // 交换e，c
            if (cmp(e, c) >= 0) break;
            array[index] = c;
            index = cIndex;
        }
        array[index] = e;
    }
}
```









# 插入排序

类似于扑克牌的排序

1. 把待排序的数组分为2部分
   - 头部是已经排好序的，尾部是待排序的
2. 从头开始扫描每一个元素
   - 每扫描一个元素，就把他插入到头部合适的地方

![image-20201230084538842](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201230084546.png)

```java
public class InsertionSort<E extends Comparable<E>> extends Sort<E> {

    @Override
    protected E[] sort() {
        for (int start = 1; start < array.length; start++) {   // 1.假设排好序的数组是 array[0]
            int cur = start;                                  // 2.记录取出元素的index
            while (cur > 0 && cmp(cur, cur - 1) < 0) {       // 3.比较 array[cur] 是不是小于 array[cur-1]
                swap(cur, cur - 1);                         // 4.交换
                cur--;                                     // 5.继续交换 -> 直到大于
            }
        }
        return array;
    }
}
```









## 优化1

![image-20201230091733920](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201230091734.png)

```java
private E[] m2() {
    for (int start = 1; start < array.length; start++) {        // 1.假设排好序的数组是 array[0]
        int cur = start;                                       // 2.记录取出元素的index
        E unSort = array[cur];                                // 3.记录取出未排序数组中的元素
        while (cur > 0 && cmp(unSort, array[cur - 1]) <0){   // 4.比较未排序元素，和已经排序的元素
            array[cur] = array[cur - 1];                    // 5.如果小于就一直交换，直到大于
            cur--;
        }
        array[cur] = unSort;                             // 6.最终排序的位置
    }
    return array;
}
```









## 二分搜索 

Binary search

### **思路**

1. 假设在[begin，end)范围内搜索某个元素V， mid = （begin + end）/ 2

![image-20201230092712866](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201230092712.png)

2. 如果 V < m -> [begin,mid）内搜索

3. 如果V > m -> [mid+1,end）内搜索

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201230092952.png)

4. 如果V = m，返回mid





### 实现

```java
public class BinarySearch {

    public static int indexOf(Object[] array, Object searchValue) {
        if (array == null || array.length == 0) {
            return -1;
        }
        int begin = 0;
        int end = array.length;
        while (begin < end) {  // 至少有一个元素
            int mid = (begin + end) >> 1;
            if (((Comparable) searchValue).compareTo(array[mid]) < 0) {  // V < m -> [begin,mid）
                end = mid;
            } else if (((Comparable) searchValue).compareTo(array[mid]) > 0) {  // V > m -> [mid+1,end）
                begin = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```





## 优化2二分搜索优化

找到第一个大于 V 的位置

```java
/**
 * 搜索插入元素的索引(在有序数组中)
 */
public static int searchInsertValueIndex(Object[] array, Object insertValue) {
    if (array == null || array.length == 0) return -1;
    int begin = 0;
    int end = array.length;
    while (begin < end) {
        int mid = (begin + end) >> 1;
        if (((Comparable) insertValue).compareTo(array[mid]) < 0) {
            end = mid;
        } else {
            begin = mid + 1;
        }
    }
    return begin;
}
```





### 实现

```java
@Override
protected E[] sort() {
    for (int begin = 1; begin < array.length; begin++) {
        E insertVal = array[begin];
        // 1.二分搜索找到插入的位置
        int l = 0;
        int r = begin;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (cmp(begin, mid) < 0) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        // 2.将[l,begin) 右移一位
        if (begin - l >= 0) System.arraycopy(array, l, array, l + 1, begin - l);
        // 3.插入
        array[l] = insertVal;
    }
    return array;
}
```



















