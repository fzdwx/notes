#  十大排序基本概览



![image-20201228083811317](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201228083818.png)









# 冒泡排序



```java
 private void m() {
        for (int i = 0; i < array.length; i++) {
            for (int j = i; j < array.length; j++) {
                if (cmp(i, j) > 0) {
                    swap(i, j);
                }
            }
        }
    }
```







## 优化1- 判断当前数组是否是有序的

如果是有序的则直接退出 

```java
 private void m1() {
        for (int i = 0; i < array.length; i++) {
            boolean sorted = true;
            for (int j = i; j < array.length ; j++) {
                if (cmp(i, j) > 0) {
                    swap(i, j);
                    sorted = false;
                }
            }
            if (sorted) break;
        }
    }
```





## 优化2-记录最后一次交换的位置

如果尾部已经有序，记录最后一次交换的位置，减少比较的次数



```java
private static void m(Integer[] array) {
    for (int end = array.length - 1; end > 0; end--) {
        int index =1;
        for (int begin = 1; begin <= end; begin++) {
            if (array[begin] > array[begin - 1]) {
                int temp = array[begin];
                array[begin] = array[begin-1];
                array[begin-1] = temp;
                index =begin;
            }
        }
        end = index;
    }
}
```







# 选择排序

1. 从数组中找到最大的那个元素，与最后的元素交换位置	
   - 执行完一轮后，最后的就是最大的元素
2. 重复执行



```java
private static void m(Integer[] array) {
    for (int i = 0; i < array.length; i++) {
        int maxIndex = i;
        for (int j = i; j < array.length; j++) {
            // 找出最大的值 记录索引
            if (array[maxIndex] > array[j]) {
                maxIndex = j;
            }
        }
        // 执行完一轮后才交换
        int temp = array[maxIndex];
        array[maxIndex] = array[i];
        array[i] = temp;
    }
}
```





# 堆排序

可以认为是对选择排序的一种优化



1. 对数组进行原地建堆
2. 重复执行,直到size = 1
   1. 交换堆顶和尾元素
   2. size–
   3. 对0位置元素进行siftDown