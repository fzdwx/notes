# 十大排序基本概览



![image-20201228083811317](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201228083818.png)









# 冒泡排序



```java
private static void m1(Integer[] array) {
    for (int i = 0; i < array.length; i++) {
        for (int j = i; j < array.length - 1; j++) {
            if (array[i] > array[j]) {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
}
```







## 优化1- 判断当前数组是否是有序的

如果是有序的则直接退出 

```java
private static void m1(Integer[] array) {
    for (int i = 0; i < array.length; i++) {
        boolean sorted = true;
        for (int j = i; j < array.length - 1; j++) {
            if (array[i] > array[j]) {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                sorted = false;
            }
        }
        if (sorted) break;
    }
}
```





## 优化2-记录最后一次交换的位置

如果尾部已经有序，记录最后一次交换的位置，减少比较的次数



```java
private static void m(Integer[] array) {
    for (int end = array.length - 1; end > 0; end--) {
        int index =1;
        for (int begin = 1; begin <= end; begin++) {
            if (array[begin] > array[begin - 1]) {
                int temp = array[begin];
                array[begin] = array[begin-1];
                array[begin-1] = temp;
                index =begin;
            }
        }
        end = index;
    }
}
```