# 递归

递归现象：

![image-20210113172509206](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210113172509.png)

函数调用过程：





# 回溯

八皇后

```java
public class eightQueen {
    /*
     * 1.暴力破解
     *   从64个格子中选出8个格子摆放皇后，检查每一种摆法的可行性
     * 一共c(8 64)种摆法
     * 2.根据题意减小暴力程度
     *   很显然，每一行只能放一个皇后，共有8^8种摆法
     * 3.回溯法
     *   选择不同的岔路口
     * */

    static int[] cols;  // index是row，元素是col
    static int ways;

    public static void main(String[] args) {
        placeQueues(4);
    }

    public static void placeQueues(int n) {
        if (n < 1) return;
        cols = new int[n];
        place(0);
    }

    /** 从第几行开始放皇 */
    private static void place(int row) {
        if (row == cols.length) { ways++;show();return; }
        for (int col = 0; col < cols.length; col++) {
            if (isValid(row, col)) { // 找到能放的地方
                cols[row] = col; // 在第row行第col列摆放
                place(row + 1); // 摆放下一列
            }
        }
    }

    /** 判断第row行的第col列能否摆放 */
    private static boolean isValid(int row, int col) {
        for (int i = 0; i < row; i++) {
            if (cols[i] == col) return false;  // 属于col列
            if (row - i == Math.abs(col - cols[i])) return false; // 属于一条斜线
        }
        return true;
    }

    private static void show() {
        for (int row : cols) {
            for (int col = 0; col < cols.length; col++) {
                if (cols[row] == col) {
                    System.out.print("1 ");
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
        }
        System.out.println("=====================");
        cols = new int[cols.length];
    }
}
```





# 贪心算法



## 1.最优装载问题

![image-20210116104603740](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210116104610.png)

```java
public class Pirate {

    public static void main(String[] args) {
        int[] weights = {3, 5, 4, 10, 7, 14, 2, 11};
        weights = Arrays.stream(weights).sorted().toArray();
        int capacity = 30, weight = 0, count = 0;
        for (int i = 0; i < weights.length && weight < capacity; i++) {
            int newWeight = weight + weights[i];
            if (newWeight <= capacity) {
                weight = newWeight;
                count++;
                System.out.println(weights[i]);
            }
        }
        System.out.println("共"+count+"件");
    }
}
```



## 2.零錢兌換

```java
public class CoinChange {

    public static void main(String[] args) {
        Integer[] faces = {25, 10, 5, 1};
        Arrays.sort(faces, (i1, i2) ->
                i2 - i1
        );
        int total = 41, coins = 0, i = 0;
        while (i < faces.length) {
            if (total < faces[i]) {
                i++;
                continue;
            }
            System.out.println(faces[i]);
            total -= faces[i];
            coins++;
        }
        System.out.println(coins);
    }
}
```



## 3.0-1背包

![image-20210116113353970](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210116113354.png)

![image-20210116113630152](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210116113630.png)





```java
public class Article {
    public int weight;
    public int value;
    public double valueDensity;

    public Article(int weight, int value) {
        this.weight = weight;
        this.value = value;
        valueDensity = value * 1.0 / weight;
    }

    @Override
    public String toString() {
        return "Article{" +
                "weight=" + weight +
                ", value=" + value +
                ", valueDensity=" + valueDensity +
                '}';
    }
}

class test {
    public static void main(String[] args) {
        Article[] articles = new Article[]{
                new Article(35,10),
                new Article(30,40),
                new Article(60,30),
                new Article(35,40),
                new Article(25,30),
                new Article(50,50),
                new Article(10,40),
        };
        Arrays.sort(articles, test::compare);
        int capacity = 150,weight=0,value=0;
        List<Article> select = new ArrayList<>();
        for (int i = 0; i < articles.length&& weight<capacity; i++) {
            int newWeight = weight + articles[i].weight;
            if (newWeight <= capacity) {
                weight = newWeight;
                value+=articles[i].value;
                select.add(articles[i]);
            }
        }
        System.out.println("总价值"+value);
        System.out.println("总重量"+weight);
        for (Article article : select) {
            System.out.println(article);
        }
    }

    private static int compare(Article a1, Article a2) {
        return a1.value - a2.value;
    }
}
```





# 分治

![image-20210116150823355](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210116150830.png)

![image-20210117105639888](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210117105647.png)

## 1.最大连续子序列和

![image-20210116152211008](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210116152211.png)

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210116152345.png)

### 1.暴力法

```java
private static int maxSubArraySum(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int max = Integer.MIN_VALUE;
    for (int start = 0; start < nums.length; start++) {
        int sum = 0;
        for (int end = start; end < nums.length; end++) {
            sum += nums[end];
            max = Math.max(sum, max);
        }
    }
    return max;
}
```



### 2.分治

```java
public static int maxSubarraySum1(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    return maxSubarraySum1(nums, 0, nums.length);
}

private static int maxSubarraySum1(int[] nums, int start, int end) {
    if (end - start < 2) return nums[start];
    int mid = (start + end) >> 1;

    int sum = 0;
    int leftMax = Integer.MIN_VALUE;
    for (int i = mid - 1; i >= start; i--) {
        sum += nums[i];
        leftMax = Math.max(leftMax, sum);
    }

    sum = 0;
    int rightMax =Integer.MIN_VALUE ;
    for (int i = mid; i < end; i++) {
        sum += nums[i];
        rightMax = Math.max(rightMax, sum);
    }
    return Math.max(leftMax+rightMax,Math.max(maxSubarraySum1(nums, start, mid), maxSubarraySum1(nums, mid, end)));
}
```





## 2.大数乘法

![image-20210117111624209](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210117111624.png)

![image-20210117112009300](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210117112009.png)





# 动态规划DP

是求解最优化问题的一种常用策略

![image-20210117112224783](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210117112224.png)

## 常用步骤

![image-20210117113242163](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210117113242.png)

## 1.动态规划解零钱兑换问题

![image-20210117113709079](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210117113709.png)

### a.暴力遞歸

```java
**
 * 需要找零的钱的总额,有25,20,5,1等面值
 */
static int coins(int money) {
    if (money < 1) {
        return Integer.MAX_VALUE;  // 如果不合法，就不用
    }
    if (money == 25 || money == 20 || money == 5 || money == 1) return 1;

    return Math.min(
            Math.min(
                    coins(money - 25),
                    coins(money - 20)
            ),
            Math.min(
                    coins(money - 5),
                    coins(money - 1)
            )) + 1;
}
```