# 设计模式概述

他描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。本质是面向对象原则的实际运用，是对类的封装性，继承性和多态性以及类的关联关系和组合关系的充分理解。

1. 可以提高思维能力，编程能力以及设计能力
2. 使程序更加标准化，代码编制更加工程化，使软件开发效率大大提高
3. 使设计的代码可重用性高，可读性高，可靠性高，灵活性好，可维护性强。



## 分类

- **创建型模式**

  用于描述`怎样创建对象`，主要特点是`将对象的创建与使用分离`，有单例，原型，工厂方法，抽象工厂，建造者等5种。

- **结构型模式**

  用于描述`如何将类或对象按某种布局组成更大的结构`，有单例，适配器，桥接，装饰，外观，享元，组合等7种。

- **行为模式**

  用于描述`类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责`，有模板，策略，命令，职责链，状态，观察者，中介者，迭代器，访问者，备忘录，解释器等11种。



# UML类图

类图(Class Diagram)是显示了模型的静态结构，特别是模型中存在的类，类的内部结构以及他们与其他类的关系等。类图不显示展示性的信息。类图是面向对象建模是主要组成部分。

1. 类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的方法，可以简化了人们对系统的理解。
2. 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要组成。



## 类图表示法

### 类的表示方法

在uml类图中，类使用包含类名(class name)、属性(field)和方法(method)且带有分割线的矩形来表示，如下图含name，age和address这3个属性，以及work()方法。

![image-20201211101126160](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211101133.png)

属性/方法名称前面的加号或减号表示了可见性，表示可见性的符号有三种

- **+**:表示public
- **-**:表示private
- **#**:表示protected

属性的完整表示方式是： 可见性  名称   ：  类型   [  =  缺省值]

方法的完整表示方式是： 可见性  名称(参数列表)  [ : 返回类型]





### 类之间的表示方法

#### 关联关系

是对象之间的一种引用关系，用于表示一类对象和另一类对象之间的联系。比如老师和学生，师傅和徒弟。关联关系有分为`一般关联关系`，`聚合关系`,`组合关系`。

一般关联又分为单向关联，双向关联，自关联



**单向关联**

![image-20201211104649894](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211104650.png)

在UML类图中单向关联用一个`带箭头的实线表示`。上图中表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。

**双向关联**

![image-20201211105029497](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211105029.png)

双向关联就是各自持有对方的类型的成员变量。

在UML类图中，双向关联用一个`不带箭头的直线表示`。上图中在Customer类中维护一个List< Prodcut >,表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客购买。

**自关联**

![image-20201211105340267](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211105340.png)

自关联用一个`带有箭头的实现且指向自己`。上图的意思就是Node类包含类型为Node的成员变量。



#### 聚合关系

是关联关系的一种，是强关联关系，是==整体和部分之间==的关系。

聚合关系也是通过成员变量来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如：学校和老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

聚合关系用`带空心菱形的实现来表示`，==菱形指向整体==。

![image-20201211142943348](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211142943.png)

#### 组合关系

组合表示类之间的整体和部分的关系，但他是一种更强烈的聚合关系。

在组合关系中，整体对象可以控制部分对象的声明周期，一旦整体对象不存在了，部分对象也不存在，不分对象不能脱离整体对象而存在。例如：头和嘴的关系，没有了头，嘴也就不存在了。

组合关系用`带实心的菱形表示`，菱形指向整体

![image-20201211143250817](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211143250.png)

#### 依赖关系

是一种使用关系，他是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数活着对静态方法的调用来访问另一个类(被依赖的类)中你的某些方法来完成一些功能。

依赖关系用`带箭头的虚线来表示`，箭头从使用类指向被依赖类。司机类使用了汽车类

![image-20201211143620869](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211143620.png)

#### 继承关系

是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类和子类之间的关系，是一种继承关系。

用`带空心三角形的实现来表示`，箭头从子类指向到父类。学生和老师类都继承了人类。

![image-20201211144015010](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211144015.png)

#### 实现关系

是接口和类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中声明的所有抽象操作。

实现关系用`带空心的三角箭头的虚线`来表示，箭头从实现类指向接口。例如：汽车和船实现了交通工具。

![image-20201211144253035](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201211144253.png)





# 设计原则

在开发中，为了提高系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发，从而提高软件开发的效率，节约开发成本和维护成本。

## 开闭原则

**对扩展开放，对修改关闭**，在==程序需要进行扩展的时候，不能去修改原有代码==，实现一个==热插拔==的效果。为了使程序的扩展性更好，易于维护和升级。

要想达到这样的效果。我们就需要使用==接口和抽象类==。抽象灵活性好，适应性广，只要抽象合理，可以基本保持软件架构的稳定。而软件中易变的细节可以中抽象派生来的实现类来进行扩展。当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了 。

![image-20201212114351520](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212114351.png)

详见代码

![image-20201212115815182](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212115815.png)



## 里氏替换原则

**任何父类可以出现的地方，子类一定可以出现**。就是子类可以扩展父类的功能，但不能改变父类原有的功能。==子类继承父类的时候，除添加新的方法完成新增功能外，尽量不要重写父类的方法==。

`如果必须要重写的方法可以定义为抽象的方法或者使用接口`。

![image-20201212120230578](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212120230.png)

![image-20201212121814986](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212121815.png)

![image-20201212121844375](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212121844.png)



## 依赖倒转原则

![image-20201212122945325](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212122945.png)

![image-20201212123123111](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212123123.png)



## 接口隔离

**一个类不应该被迫依赖它不使用的方法**，一个类对另一个类的依赖应该建立在最小接口上。

![image-20201212124214667](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212124214.png)

![image-20201212124325402](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212124325.png)

![image-20201212124345234](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212124345.png)



## 迪米特法则

又叫最少知道法则。**如果两个软件实体无需直接通信，那么就不应该直接发生相互调用，可以通过第三方转发该应用，其目的是降低类之间的耦合度，提高模块的相对独立性**







## 合成复用原则

**尽量先使用组合或者聚合等关联关系，其次才使用继承关系**。

![image-20201212130444426](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201212130444.png)





# 创建者模式

创建者模式关注的是`怎样创建对象`，主要特点是`将创建和使用分离`，这里可以降低系统的耦合度，使用者不需要关注对象的创建细节。

## 单例模式

该类提供一种访问其唯一的对象的方式，可以直接访问，不需要实例化对象。





### 饿汉式

类加载的时候创建对象



#### 静态成员变量

```java
public class Singleton {

    // 1.私有化构造器
    private Singleton() {
    }

    // 2.供外界使用的本类对象
    private static final Singleton INSTANCE = new Singleton();

    // 3.提供外界访问的方法，让外界获取对象
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```



#### 静态代码块

```java
public class Singleton {
    private Singleton() {}
    private static Singleton instance;
    
    static {
        instance = new Singleton();
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```



### 懒汉式

调用方法的时候创建



#### 线程不安全

```java
public class Singleton {
    private Singleton() {
    }

    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```



#### 双重检查

```java
public class Singleton {

    private Singleton() { }

    private static volatile Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```





#### 静态内部类

```java
public class Singleton {

    private Singleton() {

    }

    private static class SingletonCreate {
        private static final Singleton instance = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonCreate.instance;
    }
}
```







### 枚举

```java
public enum Singleton {
    instance;
}
```





### 存在的问题

**破坏单例模式**

- 反射
- 序列化







## 工厂模式

### 概述

设计一个咖啡店点餐系统

![image-20201214151303702](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214151310.png)



工厂模式的最大优点：`解耦`

- 简单工厂
- 工厂方法模式
- 抽象工厂模式



### 简单工厂模式

- 抽象产品：定义产品的规范，描述了产品的主要特性和功能
- 具体产品：实现或继承抽象产品的子类
- 具体工厂：提供创建产品的方法，调用者通过该方法来获取产品



#### 类图

![image-20201214153109038](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214153109.png)

#### 实现

新增一个咖啡工厂类，专门创建工厂

![image-20201214153704772](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214153704.png)



![image-20201214153714828](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214153714.png)





### 工厂方法模式

定义一个完全用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。

- 抽象工厂：提供了创建产品的接口，调用者通过他访问具体工厂的工厂方法来创建产品
- 具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建
- 抽象产品：定义产品的规范，描述了产品的主要特性和功能
- 具体产品：实现了抽象产品角色所定义个产品，由具体工厂来创建，和工厂一一对应。



#### 类图

![image-20201214154313896](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214154313.png)

#### 实现：

![image-20201214154845321](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214154845.png)

![image-20201214154850392](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214154850.png)

![image-20201214154857106](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214154857.png)

![image-20201214154903272](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214154903.png)



### 抽象工厂模式

抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。横轴是产品等级；纵轴是产品族，也就是通一个品牌的产品，同一品牌的产品产自同一个工厂![image-20201214155935776](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214155935.png)

抽象工厂模式可以生成多个等级的产品 。

![image-20201214160342675](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214160342.png)



#### 类图

![image-20201214160545752](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214160545.png)



#### 实现

![image-20201214161417075](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214161417.png)

![image-20201214161424189](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214161424.png)

![image-20201214161429767](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214161429.png)

![image-20201214161437916](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214161437.png)

![image-20201214161443536](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214161443.png)



### 具体使用

简单工厂+配置文件 ->解除耦合



1.**定义配置文件**

在工厂类中加载配置文件中的全类名，并使用反射创建对象进行存储，客户端如果需要对象，直接进行获取即可

![image-20201214162025853](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201214162025.png)



```java
public class SimpleCoffeeFactory {

    public static void main(String[] args) {
        Coffee usa = createCoffee("usa");
        Coffee latte = createCoffee("latte");
        System.out.println(usa.getName());
        System.out.println(latte.getName());
    }

    // 定义容器对象存储咖啡对象
    private static HashMap<String, Coffee> map = new HashMap<>();

    // 加载配置文件
    static {
        try {
            Properties properties = new Properties();
            properties.load(new InputStreamReader(new FileInputStream("src\\main\\resources\\bean.properties")));
            Set<Object> keys = properties.keySet();
            for (Object key: keys) {
                String className = properties.getProperty((String) key);
                Class<Coffee> clazz = (Class<Coffee>) Class.forName(className);
                Coffee coffee = clazz.newInstance();
                map.put((String) key, coffee);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Coffee createCoffee(String type) {
        return map.get(type);
    }
}
```





### jdk中的源码：Collection.iterator方法

![image-20201215163819915](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215163827.png)





## 原型模式

- 抽象原型类：规定了具体原型对象必须实现的clone()方法
- 具体原型类：实现抽象原型类的clone()方法，他是可被复制的对象。
- 访问类：使用具体原型类中clone()方法来复制新对象。

![image-20201215165453615](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215165453.png)



### 分类

- 浅克隆：创建一个新对象，新对象的属性和原来一样，但内存地址相同
- 深克隆：创建一个新对象，属性中引用的其他对象也会克隆，指向新的内存地址。





### 浅克隆

```java
public class People implements Cloneable{
    public People() {
        System.out.println("People创建");
    }

    @Override
    public People clone() throws CloneNotSupportedException {
        System.out.println("原型复制");
        return (People) super.clone();
    }
}
```





### 深克隆

![image-20201215173133436](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215173133.png)





## 建造者模式

- 适用于：某个对象的构建过程复杂的情况
- 实现了构建算法、装配算法的解耦，实现了很好的复用。
- 用户只需要指定复杂对象的类型就可以得到该对象。





### 结构

![image-20201216155344199](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216155351.png)

![image-20201216155509220](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216155509.png)



### 实现

```java
public class Person {

    private String name;
    private int age;
    private String address;
    private String mobilePhoneNumber;
    private Date birthDate;

    private Person() {
    }

    public  static PersonBuilder builder() {
        return new PersonBuilder();
    }
    public static class PersonBuilder {
        private String name;
        private int age;
        private String address;
        private String mobilePhoneNumber;
        private Date birthDate;

        public  Person build() {
            Person person = new Person();
            person.name = name;
            person.age = age;
            person.address = address;
            person.mobilePhoneNumber = mobilePhoneNumber;
            person.birthDate = birthDate;
            return person;
        }

        public PersonBuilder name(String name) {
            this.name = name;
            return this;
        }

        public PersonBuilder age(int age) {
            this.age = age;
            return this;
        }

        public PersonBuilder address(String address) {
            this.address = address;
            return this;
        }

        public PersonBuilder mobilePhoneNumber(String mobilePhoneNumber) {
            this.mobilePhoneNumber = mobilePhoneNumber;
            return this;
        }

        public PersonBuilder birthDate(Date birthDate) {
            this.birthDate = birthDate;
            return this;
        }
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", address='" + address + '\'' +
                ", mobilePhoneNumber='" + mobilePhoneNumber + '\'' +
                ", birthDate=" + birthDate +
                '}';
    }
}
```







# 结构型模式

结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用`继承机制`来组织接口和类,后者采用`组合或聚合来组合`对象。

由于组合关系或聚合关系比继承关系耦合度低，满足"合成复用原则”，所以`对象结构型模式比类结构型模式具有更大的灵活性。`

结构型模式分为以下7种:

- 代理模式
- 适配器模式
- 装饰者模式
- 桥接模式
- 外观模式
- 组合模式
- 享元模式

## 代理模式

由于某些原因需要给某`对象提供一个代理以控制对该对象的访问`。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

Java中的代理按照代理类生成时机不同又分为`静态代理`和`动态代理`。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和cGLib代理两种。

代理(Proxy）模式分为三种角色:

- 抽象主题(subject)类:通过接口或抽象类声明真实主题和代理对象实现的业务方法。

- 真实主题(Real Subject)类:实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。

- 代理(Proxy)类︰提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

### 静态代理

![image-20201217170805720](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217170805.png)

```java
/**
 * @description 卖火车票 - 抽象主题
 */
public interface SellTickets {
    void  sell();
}
/**
 * @description 具体主题
 */
public class TrainStation  implements SellTickets{

    @Override
    public void sell() {
        System.out.println("火车站卖了一张票");
    }
}

/**
 * @description 代理
 */
public class ProxyPoint implements SellTickets{

    private  TrainStation trainStation = new TrainStation();
    @Override
    public void sell() {
        System.out.println("代理收取服务费");
        trainStation.sell();
    }
}
```