# 行为模式

行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。

行为型模式分为==类行为模式== 和==对象行为模式==，==前者采用继承机制==来在类间分派行为，后者采用==组合或聚合== 在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足"合成复用原则”，所以==对象行为模式==比类行为模式具有==更大的灵活性。== 

 

## 模板方法模式



在面向对象程序设计过程中，程序员常常会遇到这种情况:设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。

例如，去银行办理业务一般要经过以下4个流程:取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。
**定义:**
      定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。



### 结构

模板方法(Template Method)模式包含以下主要角色

- 抽象类(Abstract class)︰负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。
- 模板方法:定义了算法的骨架，按某种顺序调用其包含的基本方法。
- 基本方法:是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种:
  - 抽象方法(Abstract Method) :一个抽象方法由抽象类声明、由其具体子类实现
  - 具体方法(Concrete Method) :一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继
  - 钩子方法(Hook Method):在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXx，返回值类型为boolean类型。
- 具体子类(Concrete class)︰实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。



### 实现

```java
public abstract class AbstractClass {

    // 模板方法->不能个修改
    public final void cookProcessing() {
        pourOil();
        heatOil();;
        pourVeg();
        pourSauce();
        fry();
    }

    private void pourOil() {
        System.out.println("倒油");
    }

    private void heatOil() {
        System.out.println("热油");
    }

    private void fry() {
        System.out.println("翻炒");
    }
    /**
     * 倒入蔬菜
     */
    protected   abstract void pourVeg();

    /**
     * 倒入调料
     */
    protected abstract void pourSauce();
}
```



```java
public class BaoCai extends AbstractClass {

    @Override
    protected void pourVeg() {
        System.out.println("放入包菜");
    }

    @Override
    protected void pourSauce() {
        System.out.println("放入辣椒");
    }
}
```





```java
public class Main{
    public static void main(String[] args) {
        BaoCai c = new BaoCai();
        c.cookProcessing();
    }
}
```





### 总结


优点:

- 提高代码复用性
  将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。
- 实现了反向控制
  通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合"开闭原则”。

缺点:

- 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
- 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。



**使用场景**

- 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
- 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。







## 策略模式

​	该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，并且算法的变化不会影响算法的使用客户。策略模式通过对算法的封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

### 结构

策略模式的主要角色如下:

- 抽象策略(strategy)类:这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
- 具体策略（(Concrete strategy)类:实现了抽象策略定义的接口，提供具体的算法实现或行为。
- 环境(context)类:持有一个策略类的引用，最终给客户端调用。





### 案例

![image-20201226162934084](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201226162934.png)



### 代码

**策略**

```java
public interface Strategy {

    void show();
}

public class StrategyB implements Strategy {

    @Override
    public void show() {
        System.out.println("满200-100");
    }
}

public class StrategyA implements Strategy {

    @Override
    public void show() {
        System.out.println("买一送一");
    }
}


```



**环境**

```java
public class SaleMan {
    private Strategy strategy;

    public SaleMan(Strategy strategy) {
        this.strategy = strategy;
    }

    public void salesManShow() {
        strategy.show();
    }
}
```





### 总结

1、优点:

- 策略类之间可以自由切换
  由于策略类都实现同一个接口，所以使它们之间可以自由切换。

- 易于扩展
  增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合"开闭原则"。避免使用多重条件选择语句(if else)，充分体现面向对象设计思想。

  



2、缺点:

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
- 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。