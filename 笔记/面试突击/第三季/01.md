# 1.你知道HashMap底层的数据结构是什么样的吗？

## a.JDK1.8中对hash算法和寻址算法是如何优化的

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

tatic final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

比如有一个key的hash值：

1111 1111 1111 1111 1111 1010 0111 1100 

=> 右移16位

0000 0000 0000 0000 1111 1111 1111 1111

=> 进行 异或运算 ^ (相同是0，不同是1)

1111 1111 1111 1111 0000 0101 1000 0011 



**寻址算法**

用与运算替代取模，提升性能，n是hash表的长度（2的n次方）

(n-1) & hash



## b.是如何解决hash冲突的

如果发生hash冲突，这个索引位置就会形成单向链表

当这个单向链表的长度大于等于8时，就会成为一颗红黑树



## c.hashMap是如何扩容的

16位的hash表->32位

进行rehash()



# 2.synchronize关键字的底层原理

monitor 内部有一个计数器，加锁后会加1，释放锁后就会减1

monitorenter 加锁

monitorexit 释放锁





# 3.对CAS的理解

compare and swap

> 比较和交换
>
> 当要修改一个值的时候，就会获取到当前这个值的内容，然后去和内存中的比较，如果是一样的就继续进行操作。

多个线程同时对一个线程进行以下操作

1. 可以使用synchronized加锁
2. 使用Atomic原子类
3. 使用volatile关键字

~~~java
public  method(int i){
    i++;
}
~~~



# 4.concurrentHashMap实现线程安全的底层原理

**JDK1.8以前**：

​	多个数组，分段加锁，一个数组一个锁

**JDK1.8以后**：

优化细粒度：一个数组，每个元素进行cas。如果失败了就说明有人了

就对该数组进行加锁。链表+红黑树处理，对数组每个元素加锁





# 5.AQS

abstract queue synchronize 抽象队列同步器





# 6.线程池的底层工作原理

```java
Executor executor = new ThreadPoolExecutor(
    10, // 常驻线程
    20, // 最大线程
    3L, // 线程任务结束后等待的时间
    TimeUnit.SECONDS // 等待时间单位
    ,new LinkedBlockingQueue<>(100), // 线程执行任务保存的阻塞队列 
    Executors.defaultThreadFactory(),	// 线程的创建工厂
    new ThreadPoolExecutor.AbortPolicy());	// 任务打满了阻塞队列的拒绝策略
```



**如果服务器突然宕机，线程池的阻塞队列中的请求怎么办？**

导致线程池里面积压的任务都会丢失。

1. 如果要提交一个任务到线程池中，在提交之前保存这个任务的信息，更新状态

   未提交、已提交、已完成。提交成功后，更新他的状态是已提交状态。

2. 系统重启后，扫描所有未提交和已提交状态的任务，重新读取到阻塞队列中去





# 7.对Java内存模型的理解

将数据从主内存中==read==出来然后==load==到工作内存中==use==，然后==assign==完毕后，==store==到工作内存中，最后==write==到主内存

![image-20210228190157565](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210228190204.png)



# 8.Java内存模式中的原子性、有序性、可见性是什么

**可见性**：

当一个线程修改的内存中的值的时候， 没有立即刷新到主内存中叫没有可见性

**原子性**：

两个线程对一个内容进行操作时

一个线程进行操作时，其他线程是不能进行操作的，直到写入到主内  存

**有序性**

在编译期，可以防止指令重排





# 9.volatitle关键字的原理

用来解决可见性和有序性，可以有限的保证原子性





# 10.指令重排和happens-before

**happens-before原则：**在一些特殊情况下不允许编译器对代码进行指令重排

1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作现行发生于书写在后面的操作

2.锁定规则：一个unlock操作先行发生于后面对同一个锁 lock操作

3.volatile原则：对一个变量的写操作先行发生于对这个变量的读操作

4,传递规则：如果操作A先行发生于操作b，操作b又先行发生于操作c，则可以得出操作a先行发生于操作c

5.线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作

6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生

7.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始





# 11.volatile底层是如何基于内存屏障保证可见性和有序性的

## 有序性：

如果给一个变量加上volatile关键字会在他的字节码前后会加入一些屏障

![image-20210228212600716](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210228212600.png)

## 可见性

如果对volatile修饰的变量进行写操作的说，jvm会发送一条lock前缀指令给cpu，cpu在计算完后会立即将这个值写回主内存，因为有mesi缓存一致性协议。