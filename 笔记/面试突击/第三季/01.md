

# 1.你知道HashMap底层的数据结构是什么样的吗？

## a.JDK1.8中对hash算法和寻址算法是如何优化的

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

tatic final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

比如有一个key的hash值：

1111 1111 1111 1111 1111 1010 0111 1100 

=> 右移16位

0000 0000 0000 0000 1111 1111 1111 1111

=> 进行 异或运算 ^ (相同是0，不同是1)

1111 1111 1111 1111 0000 0101 1000 0011 



**寻址算法**

用与运算替代取模，提升性能，n是hash表的长度（2的n次方）

(n-1) & hash



## b.是如何解决hash冲突的

如果发生hash冲突，这个索引位置就会形成单向链表

当这个单向链表的长度大于等于8时，就会成为一颗红黑树



## c.hashMap是如何扩容的

16位的hash表->32位

进行rehash()



# 2.synchronize关键字的底层原理

monitor 内部有一个计数器，加锁后会加1，释放锁后就会减1

monitorenter 加锁

monitorexit 释放锁





# 3.对CAS的理解

compare and swap

> 比较和交换
>
> 当要修改一个值的时候，就会获取到当前这个值的内容，然后去和内存中的比较，如果是一样的就继续进行操作。

多个线程同时对一个线程进行以下操作

1. 可以使用synchronized加锁
2. 使用Atomic原子类
3. 使用volatile关键字

~~~java
public  method(int i){
    i++;
}
~~~



# 4.concurrentHashMap实现线程安全的底层原理

**JDK1.8以前**：

​	多个数组，分段加锁，一个数组一个锁

**JDK1.8以后**：

优化细粒度：一个数组，每个元素进行cas。如果失败了就说明有人了

就对该数组进行加锁。链表+红黑树处理，对数组每个元素加锁





# 5.AQS

abstract queue synchronize 抽象队列同步器





# 6.线程池的底层工作原理

```java
Executor executor = new ThreadPoolExecutor(
    10, // 常驻线程
    20, // 最大线程
    3L, // 线程任务结束后等待的时间
    TimeUnit.SECONDS // 等待时间单位
    ,new LinkedBlockingQueue<>(100), // 线程执行任务保存的阻塞队列 
    Executors.defaultThreadFactory(),	// 线程的创建工厂
    new ThreadPoolExecutor.AbortPolicy());	// 任务打满了阻塞队列的拒绝策略
```



**如果服务器突然宕机，线程池的阻塞队列中的请求怎么办？**

导致线程池里面积压的任务都会丢失。

1. 如果要提交一个任务到线程池中，在提交之前保存这个任务的信息，更新状态

   未提交、已提交、已完成。提交成功后，更新他的状态是已提交状态。

2. 系统重启后，扫描所有未提交和已提交状态的任务，重新读取到阻塞队列中去





# 7.对Java内存模型的理解

将数据从主内存中==read==出来然后==load==到工作内存中==use==，然后==assign==完毕后，==store==到工作内存中，最后==write==到主内存

![image-20210228190157565](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210228190204.png)



# 8.Java内存模式中的原子性、有序性、可见性是什么

**可见性**：

当一个线程修改的内存中的值的时候， 没有立即刷新到主内存中叫没有可见性

**原子性**：

两个线程对一个内容进行操作时

一个线程进行操作时，其他线程是不能进行操作的，直到写入到主内  存

**有序性**

在编译期，可以防止指令重排





# 9.volatitle关键字的原理

用来解决可见性和有序性，可以有限的保证原子性





# 10.指令重排和happens-before

**happens-before原则：**在一些特殊情况下不允许编译器对代码进行指令重排

1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作现行发生于书写在后面的操作

2.锁定规则：一个unlock操作先行发生于后面对同一个锁 lock操作

3.volatile原则：对一个变量的写操作先行发生于对这个变量的读操作

4,传递规则：如果操作A先行发生于操作b，操作b又先行发生于操作c，则可以得出操作a先行发生于操作c

5.线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作

6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生

7.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始





# 11.volatile底层是如何基于内存屏障保证可见性和有序性的

## 有序性：

如果给一个变量加上volatile关键字会在他的字节码前后会加入一些屏障

![image-20210228212600716](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210228212600.png)

## 可见性

如果对volatile修饰的变量进行写操作的说，jvm会发送一条lock前缀指令给cpu，cpu在计算完后会立即将这个值写回主内存，因为有mesi缓存一致性协议。





# 12.对Spring IOC 和AOP的理解

**ioc：**

根据xml配置或者注解，去实例化我们的所有bean，并管理bean之间的依赖注入，让类和类之间解耦，维护代码的时候更加轻松便利。

**aop：**

比如说我们有很多方法是和数据库增删改查相关的操作，我们要对这些方法都增加事务，而管理事务的代码基本都是相同的，所以我们就可以为这些方法添加一个切面类，在方法运行前，开启一个事务，在运行完毕后根据是否抛出异常来决定是否回滚。





# 13.cglib和jdk动态代理

在spring里面使用aop，比如说对一些类的方做了一个切面，定义好了要在这些类的方法里面增强代码，spring就会对这些类进行动态代理。

如果这个类实现了某个类 -> JDK ：生成一个跟你实现了同一个接口的代理类

如果没有实现接口 -> cglib：生成该类的一个子类，可以动态生成字节码，覆盖你的一些方法，在方法里面加入增强的代码





# 15.spirng 事务实现的原理，

~~~
1.REQUIRED：
	使用当前的事务，如果没有事务则自己新建一个事务，子方法必须运行在一个事务中；
	如果当前存在事务，则加入这个事务，成为一个整体。
2.SUPPORTS：
	如果有事务，就加入事务
	如果没有事务，就不使用	
3.MANDATORY
	强制必须存在事务，如果没有事务就会抛出异常
4.REQUIRES_NEW
	如果存在事务，则挂起该事务，并且自己创建一个新的事务给自己使用；
5.NOT_SUPPORTED
	如果存在事务，就挂起事务，自己不使用事务
6.NEVER
	如果存在事务就抛出异常
7.NESTED
	如果有事务，则开启子事务(嵌套事务)，嵌套事务是独立提交或者回滚的；
	如果没有事务就开启一个事务。
	但是如果主事务提交，子事务也会一起提交，
	如果主事务回滚，则子事务就会一起回滚。相反，子事务异常，则父事务可以回滚或不回滚
~~~







# 16.网络模型

TCP/IP

~~~
1.应用层
2.传输层
3.网络层
4.数据链路层
~~~

~~~
应用层 
 ||
 \/
应用层 表示层 会话层 
~~~





# 17.浏览器发送请求的过程



~~~
1.浏览器发生请求
2.寻找dns服务器获取具体请求的ip地址
3.判断获得到的ip和当前ip是否是一个子网
4.应用层 封装成一个数据包通常使用http 或https协议 
5.会话层 会封装源端口和目标端口 通常使用tcp 或udp
6.网络层 封装上源ip和目标ip icmp
7.数据链路层 封装网卡的mac地址
8.发送到网关
9.服务器收到后，层层解包
~~~





# 18.tcp三次握手四次挥手

~~~
客户端																	  服务端
第一次握手    
     客户端发送连接请求  SYN=1,ACK=0,seq=x     SYN_SENT
第二次握手
	 服务端返回响应   ack=x+1,SYN=1,ACK=1,seq=y
第三次握手
	 客户端发送      ack=y+1,ACK=1,seq=x+1
~~~





~~~
客户端																	  服务端
第一次挥手
	客户端 发送请求 FIN=1,seq=x,此时进入 FIN-WAIT-1状态
第二次挥手
    服务端 收到 进入 CLOSE_WATI状态，返回ACK=1,ack=x+1,seq=y。
    客户端 收到 进入 FIN-WAIT-2状态，客户端到服务端的连接释放
第三次挥手
	服务端发送连接释放报文，FIN=1,ack=x+1，seq=a, 服务端进入LACK-ACK
第四次挥手
	客户端收到后，发送报文 ACK=1,ack=a+1，seq=x+1，进入TIME_WAIT
    客户端进入CLOSED状态，服务端进入CLOSED状态
	
~~~





# 19.http 1.0、http 1.1、http 2.0

> http1.0

是默认短连接，每次浏览器请求都要重现建立起一次tcp连接



> http1.1

默认长连接，底层的tcp连接一直保持着



> http2.0

支持多路复用，基于一个tcp连接并行发送多个请求 以及接受响应。解决了http1.1对同一时间同一个域名的请求有限制的问题。







# 20.https

~~~
1.浏览器把自己支持的加密规则发送给网站
2.网站从加密规则里面选出一套加密算法和hash算法，然后把自己的身份信息用证书的方式发回给浏览器，证书里面有网站地址，加密公钥，证书颁发机构
3.浏览器会验证证书的合法性，然后生成一段随机密码，用公钥进行加密(非对称加密)；用约定好的hash算法生成握手消息的hash值，然后用密码对消息进行加密，最后把所有数据发送给网站(对称加密)
4.网站用私钥对消息解密出密码，然后用密码解密出浏览器发送的握手消息，计算消息的hash值，验证和浏览器发送的hash值是否一样，最后用密码加密一段握手消息，发送给浏览器
5，浏览器解密握手消息，然后计算消息的hash值，如果和网站发送的一样，握手就结束，然后所有的数据会用之前生成的随机密码进行加密，然后用对称加密来进行加密

非对称RSA,
~~~









# 21.mysql引擎

myisam

~~~
不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能更好，使用于纯查询额度需求
~~~

innodb

~~~
支持事务。默认的事务隔离级别为可重复读，通过MVCC（并发版本控制）来实现的。
支持外键约束
使用的锁粒度为行级锁，可以支持更高的并发
~~~



## B+树

![image-20210302122757270](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210302122804.png)

![image-20210302122909357](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210302122909.png)

![image-20210302122938756](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210302122938.png)





