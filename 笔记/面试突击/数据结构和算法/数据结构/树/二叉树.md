#  	 树形结构

![image-20201215092652815](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215092700.png)



# 基本概念



- 节点、根节点、父节点、子节点、兄弟节点 
- 一棵树可以没有任何节点，称为`空树`
- 一颗树可以只有一个节点，也就是`根节点`
- 子树、左子树、右子树



- `节点的度:子树的个数`
- `树的度`：所有节点`度中的最大值`
- 叶子节点：度为0的节点
- 非叶子节点：度不是0的
- 层数：根节点在第一层，根节点的子节点在第二层，依次类推
- 节点的深度：从==根节点==到当==前节点==唯一路径上的节点总数
- 节点高度：==当前节点==到==最远叶子节点==的路径上的节点总数
- 树的深度：所有节点深度的最大值
- 树的高度：所有节点高度中的最大值

![image-20201215104822543](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215104822.png)

- 有序树：树中任意节点的子节点之间有顺序关系
- 无序树：树中任意节点的子节点直接没有顺序关系
- 森林：由m(m>=0)棵不相交的树组成的集合





# 二叉树

1. 每个节点的度最大为2(最大有2个子树)
2. 左子树和右子树是有顺序的
3. 非空二叉树的第`i`层，最多有`2^i-1`个节点(第几层有多少个节点)
4. 在层数为`h`的二叉树上最多有 `(2^h)-1`个节点
5. 对于一个二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则：n0 = n2 +1
   1. 假设度为1的节点个数为n1，则：n=n0+n1+n2
   2. 二叉树的边数T = n1+2*n2 = n-1 = n0 + n1 + n2-1



## **真二叉树**

所有节点的度要么都为0，要么为2

![image-20201215110258988](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215110259.png)

## **满二叉树**

所有节点的度要么都为0，要么为2。且所有的叶子节点都在最后一层

![image-20201215110224968](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215110225.png)

- 假设满二叉树的层数是h
  - 第i层的节点数量：2^(i-1)
  - 叶子节点数量：2^(h-1)
  - 总节点数量:n = (2^h)  - 1
  - 高度： log2 2(n + 1)





## **完全二叉树**

**从树的根节点，从上到下，从左到右依次填满节点形成的二叉树**

所有叶子节点只会出现在最后2层，且最后1层的叶子节点都靠左对齐

- 度为1的节点只有左子树
- 度为1的节点要么是1个，要么是0个
- 同样节点数量的二叉树，完全二叉树的高度是最小的
- 如果完全二叉树的层树是h
  - 至少有2^(h-1)个节点
  - 最多有(2^h)-1个节点

![image-20201215111913702](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215111913.png)

![image-20201215113159137](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215113159.png)





**公式总结**

![image-20201215114015251](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215114015.png)







# 二叉搜索树

任意一个左节点的值小于任意右节点



## 接口设计

![image-20201215120533406](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215120533.png)





## add()

```java
public void add(T element) {
    elementNotNullCheck(element);

    // 1.初始化条件
    Node<T> temp = this.root;                      // 遍历的元素
    Node<T> parent = this.root;                   // 插入元素的父节点
    int compare = 0;                             // 记录插入位置
    Node<T> curr = new Node<>(element, parent); // 需要插入的元素

    // 2.找到父节点，以及插入位置
    // 2.a.判断根节点是否为空
    if (temp != null) {
        // 2.b.存在根节点，查找当前节点的父节点  parent.left/right = curr
        while (temp != null) {
            compare = compare(element, temp.element);
            parent = temp;
            if (compare > 0) {
                temp = temp.right;
            } else if (compare < 0) {
                temp = temp.left;
            } else {
                return;
            }
        }
    } else {
        root = curr;
    }

    // 3.添加节点
    curr.parent = parent;
    if (compare > 0) {
        parent.right = curr;
    } else if (compare < 0) {
        parent.left = curr;
    }
    size++;

}
```



## compare()

在设置泛型的时候必须规定要实现Comparable

![image-20201215130805459](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215130805.png)

```java
/**
 * 比较
 *
 * @param element 需要添加的元素
 * @param compare 比较的对象
 * @return {@link Integer}
 * 返回0 表示相等         覆盖
 * 大于0 表示element大    右边
 * 小于0 表示compare大    左边
 */
private Integer compare(T element, T compare) {
    return element.compareTo(compare);
}
```





### 方法二

![image-20201216101222721](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216101229.png)



![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216101233.png)





## 二叉树遍历

![image-20201215114954341](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215114954.png)

![image-20201215115210407](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201215115210.png)





### 前序遍历 pre order  traversal

根节点 =>，前序遍历`左`子树 => 前序遍历`右`子树

```java
/**
 * 前序遍历
 *
 * @return {@link List<T>}
 */
public List<T> preorderTraversal() {
    List<T> list = new ArrayList<>();
    preorderTraversal(root, list);
    return list;
}


private List<T> preorderTraversal(Node<T> root, List<T> list) {
    if (root == null) {
        return list;
    }
    // root 节点
    list.add(root.element);
    // 前序遍历 左子树
    preorderTraversal(root.left, list);
    // 前序遍历 右子树
    preorderTraversal(root.right, list);
    
    return list;
}
```





### 中序遍历 in order traversal

```java
public List<T> inorderTraversal() {
    List<T> list = new ArrayList<>();
    return inorderTraversal(root, list);
}

private List<T> inorderTraversal(Node<T> root, List<T> list) {
    if (root == null) {
        return list;
    }
    inorderTraversal(root.left,list);
    list.add(root.element);
    inorderTraversal(root.right,list);
    return list;
}
```





### 后序遍历 post order

```java
/**
 * 后序遍历
 *
 * @return {@link List<T>}
 */
public List<T> postorderTraversal() {
    List<T> list = new ArrayList<>();
    return postorderTraversal(root, list);
}

private List<T> postorderTraversal(Node<T> root, List<T> list) {
    if (root == null) {
        return list;
    }
    postorderTraversal(root.left,list);
    postorderTraversal(root.right,list);
    list.add(root.element);
    return list;
}
```



### 层序遍历

```java
/**
 * 层序遍历
 *
 * @return {@link List<T>}
 */
public List<T> levelOrderTraversal() {
    List<T> list = new ArrayList<>();

    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();
        list.add(poll.element);
        if (poll.left != null) {
            queue.offer(poll.left);
        }
        if (poll.right != null) {
            queue.offer(poll.right);
        }
    }
    return list;
}
```





### 使用访问者模式修改

1.添加一个接口，回调。

```java
public interface Visitor<T> {
    void visit(T element);
}
```





2.让使用者传入接口的实现，表明要用这个元素干什么

![image-20201216121342090](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216121342.png)





### 增强遍历接口 —— 随时停止

1.修改接口为抽象类，但是不能使用lambda表达式了

```java
public static abstract class Visitor<T> {
    /**
     * 访问
     * 返回false 继续遍历
     * 返回true 停止遍历
     *
     * @param element 元素
     * @return boolean
     */
    public abstract boolean visit(T element);

    public boolean continueTo = false;
}
```





2.修改实现

![image-20201216130514197](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216130514.png)



![image-20201216130531139](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216130531.png)





## 计算二叉树的高度

```java
public int height() {
    return height(root);
}

private int height(Node<T> root) {
    if (root == null) {
        return 0;
    }
    return Math.max(height(root.left),height(root.right)) + 1;
}
```



~~~java
public int height2() {
    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);
    int h = 0;  // 记录高度
    int levelSize = 1; // 记录当前层级元素剩余个数
    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();  // 当前层级元素出队
        levelSize --;
        if (poll.left != null) {
            queue.offer(poll.left);   // 把当前层级元素入队
        }
        if (poll.right != null) {
            queue.offer(poll.right);  // 把当前层级元素入队
        }
        if (le		velSize == 0) {        // 如果当前层级元素出队完毕
            levelSize = queue.size();
            h++;
        }
    }
    return h;
}
~~~





## 判断二叉树是否完全二叉树

![image-20201216140057538](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216140057.png)



~~~java
public boolean isComplete() {
    if (root == null) {
        return false;
    }
    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);
    boolean leaf = false;
    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();  // 当前层级元素出队

        if (leaf && !poll.isLeaf()) {  // 如果没有叶子节点
            return false;
        }
        if (poll.hasChildren()) { //如果当前节点有子节点
            queue.offer(poll.left);
            queue.offer(poll.right);
        } else if (poll.left == null && poll.right != null) {  // 如果没有左子节点但是有右子节点->不是
            return false;
        } else {
            leaf = true;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
        }

    }
    return true;
}
~~~

![image-20201216141553100](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201216141553.png)





```java
public boolean isComplete2() {
    if (root == null) {
        return false;
    }
    Queue<Node<T>> queue = new LinkedList<>();
    queue.offer(root);
    boolean leaf = false;
    while (!queue.isEmpty()) {
        Node<T> poll = queue.poll();  // 当前层级元素出队
        if (leaf && !poll.isLeaf()) {
            return false;
        }
        if (poll.left != null) { // 入队
            queue.offer(poll.left);
        } else if (poll.right != null) { // 没有左子节点，但有右子节点 -> 不是
            return false;
        }
        if (poll.right != null) { // 入队
            queue.offer(poll.right);
        } else {  // 右子节点为空，则往后的节点都必须是叶子节点
            leaf = true;
        }
    }
    return true;
}
```





## 反转二叉树

```java
public class _226反转二叉树 {

    /**
     * 倒置的树
     * 使用前序遍历
     *
     * @param root 根
     * @return {@link TreeNode}
     */
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        // 交换
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        invertTree(root.left);
        invertTree(root.right);
        return root;
    }


    public TreeNode invertTree2(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode poll = queue.poll();
            // 交换
            TreeNode temp = poll.left;
            poll.left = poll.right;
            poll.right = temp;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }
        }
        return root;
    }
}
```



## 根据遍历结果重构二叉树

![image-20201217104819368](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217104826.png)









## 前驱节点

![image-20201217110433903](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217110434.png)



```java
public Node<T> predecessor(Node<T> node) {
    if (node == null) {
        return null;
    }
    Node<T> p = node.left;
    // 前驱节点在左子树中,left.right.right.right  ...
    if (p != null) {
        while (p.right != null) {
            p = p.right;
        }
        return p;
    }
    p = node;
    // 前驱节点在父节点的左父节点
    while (p.parent != null && p == p.parent.left) { // 父节点==null，当前节点是父节点的右节点
        p = p.parent;
    }
    return p.parent;
}
```



## 后继节点

![image-20201217113447664](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201217113447.png)

```java
public Node<T> successor(Node<T> node) {
    if (node == null) {
        return null;
    }
    Node<T> p = node.right;
    // 后继节点在右子树中,right.left.left.left  ...
    if (p != null) {
        while (p.left != null) {
            p = p.left;
        }
        return p;
    }
    p = node;
    // 后继节点在父节点的右父节点
    while (p.parent != null && p == p.parent.right) { // 父节点==null，当前节点是父节点的左节点
        p = p.parent;
    }
    return p.parent;
}
```





## remove()

如果一个节点的度为2,那么他的前驱、后继节点的度只可能是0或1

### 思路

```java
1.删除叶子节点(n0)  - 直接删除
2.删除n1  - 用子节点代替原节点的位置 node.left/right.parent = node.parent
3.删除n2  先用前驱或后继节点覆盖原节点，然后删除对应的前驱或后继
```

### 实现

```java
/**
 * 删除
 *
 * @param node 节点
 */
private void remove(Node<T> node) {
    if (node == null) {
        return;
    }

    if (node.hasTwoChildren()) {        // n2
        Node<T> s = predecessor(node);   // 要删除节点的后继节点
        node.element = s.element;     // 删除当前节点(覆盖当前节点所保存的值)
        node = s;
    }

    //n1、n0
    Node<T> removeNext = node.left != null ? node.left : node.right;   // 判断要删除的节点是否有子节点
    if (removeNext != null) {                                         // n1
        removeNext.parent = node.parent;                             // removeNext -> node.parent
        if (node.parent == null) {                                  // 根节点
            root = removeNext;
        } else if (node == node.parent.left) {                    // node.parent.left/right -> removeNext
            node.parent.left = removeNext;
        } else {
            node.parent.right = removeNext;
        }
    } else if (node.parent == null) {  // n0且没有父节点 ->root
        root = null;
    } else {     // n0  直接删除
        if (node.parent.left == node) {
            node.parent.left = null;
        } else if (node.parent.right == node) {
            node.parent.right = null;
        }
    }

    size--;
}
```





# 二叉树继承树重构

## BinaryTree

```java
abstract class BinaryTree<T> implements BinaryTreeInfo {

    protected int size;
    protected Node<T> root;

    /**
     * 获得元素的节点
     *
     * @param element 元素
     * @return {@link Node<T>}
     */
    public abstract Node<T> getNodeForElement(T element);

    public abstract void add(T element);

    public int size() {
        return size;
    }

    public boolean empty() {
        return size == 0;
    }

    public void clear() {
        root = null;
        size = 0;
    }

    public boolean contains(T element) {
        return getNodeForElement(element) != null;
    }

    /**
     * 删除
     *
     * @param element 元素
     */
    public void remove(T element) {
        // 1.删除叶子节点(n0)  - 直接删除
        // 2.删除n1  - 用子节点代替原节点的位置 node.left/right.parent = node.parent
        // 3.删除n2  先用前驱或后继节点覆盖原节点，然后删除对应的前驱或后继
        remove(getNodeForElement(element));
    }

    /**
     * 删除
     *
     * @param node 节点
     */
    public void remove(Node<T> node) {
        if (node == null) {
            return;
        }

        if (node.hasTwoChildren()) {        // n2
            Node<T> s = predecessor(node);   // 要删除节点的后继节点
            node.element = s.element;     // 删除当前节点(覆盖当前节点所保存的值)
            node = s;
        }

        //n1、n0
        Node<T> removeNext = node.left != null ? node.left : node.right;   // 判断要删除的节点是否有子节点
        if (removeNext != null) {                                         // n1
            removeNext.parent = node.parent;                             // removeNext -> node.parent
            if (node.parent == null) {                                  // 根节点
                root = removeNext;
            } else if (node == node.parent.left) {                    // node.parent.left/right -> removeNext
                node.parent.left = removeNext;
            } else {
                node.parent.right = removeNext;
            }
        } else if (node.parent == null) {  // n0且没有父节点 ->root
            root = null;
        } else {     // n0  直接删除
            if (node.parent.left == node) {
                node.parent.left = null;
            } else if (node.parent.right == node) {
                node.parent.right = null;
            }
        }

        size--;
    }

    /**
     * 高度
     *
     * @param type 类型  1 ->递归  2->迭代
     * @return int
     */
    public int height(int type) {
        if (type == 1) {
            return height(root);
        } else if (type == 2) {
            return heightIteration();
        }
        return 0;
    }

    /**
     * 判断是不是完全二叉树
     *
     * @return boolean
     */
    public boolean isComplete() {
        if (root == null) {
            return false;
        }
        Queue<Node<T>> queue = new LinkedList<>();
        queue.offer(root);
        boolean leaf = false;
        while (!queue.isEmpty()) {
            Node<T> poll = queue.poll();  // 当前层级元素出队
            if (leaf && !poll.isLeaf()) {
                return false;
            }
            if (poll.left != null) { // 入队
                queue.offer(poll.left);
            } else if (poll.right != null) { // 没有左子节点，但有右子节点 -> 不是
                return false;
            }
            if (poll.right != null) { // 入队
                queue.offer(poll.right);
            } else {  // 右子节点为空，则往后的节点都必须是叶子节点
                leaf = true;
            }
        }
        return true;
    }

    /**
     * 得到节点使用递归
     *
     * @param element 元素
     * @return {@link Node<T>}
     */
    protected Node<T> getNodeUseRecursive(T element) {
        if (element == null || root == null) {
            return null;
        }

        ArrayList<Node<T>> list = new ArrayList<>();
        inorderTraversal(new Visitor<T>() {
            @Override
            public boolean visit(Node<T> node) {
                if (node.element == element) {
                    list.add(node);
                    return true;
                }
                return false;
            }
        });

        // 添加判断
        return list.size() > 0 ? list.get(0) : null;
    }

    /**
     * 前驱
     *
     * @param node 节点
     * @return {@link Node<T>}
     */
    public Node<T> predecessor(Node<T> node) {
        if (node == null) {
            return null;
        }
        Node<T> p = node.left;
        // 前驱节点在左子树中,left.right.right.right  ...
        if (p != null) {
            while (p.right != null) {
                p = p.right;
            }
            return p;
        }
        p = node;
        // 前驱节点在父节点的左父节点
        while (p.parent != null && p == p.parent.left) { // 父节点==null，当前节点是父节点的右节点
            p = p.parent;
        }
        return p.parent;
    }

    /**
     * 后继
     *
     * @param node 节点
     * @return {@link Node<T>}
     */
    public Node<T> successor(Node<T> node) {
        if (node == null) {
            return null;
        }
        Node<T> p = node.right;
        // 后继节点在右子树中,right.left.left.left  ...
        if (p != null) {
            while (p.left != null) {
                p = p.left;
            }
            return p;
        }
        p = node;
        // 后继节点在父节点的右父节点
        while (p.parent != null && p == p.parent.right) { // 父节点==null，当前节点是父节点的左节点
            p = p.parent;
        }
        return p.parent;
    }

    /**
     * 前序遍历
     *
     * @return {@link List <T>}
     */
    public void preorderTraversal(BinarySearchTree.Visitor<T> visitor) {
        if (visitor == null) {
            return;
        }
        preorderTraversal(root, visitor);
    }


    /**
     * 中序遍历
     *
     * @return {@link List<T>}
     */
    public void inorderTraversal(BinarySearchTree.Visitor<T> visitor) {
        if (visitor == null) {
            return;
        }
        inorderTraversal(root, visitor);
    }

    /**
     * 后序遍历
     *
     * @return {@link List<T>}
     */
    public void postorderTraversal(BinarySearchTree.Visitor<T> visitor) {
        if (visitor == null) {
            return;
        }
        postorderTraversal(root, visitor);
    }

    /**
     * 层序遍历
     *
     * @return {@link List<T>}
     */
    public void levelOrderTraversal(BinarySearchTree.Visitor<T> visitor) {
        if (root == null || visitor == null || visitor.continueTo) {
            return;
        }
        Queue<Node<T>> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            Node<T> poll = queue.poll();
            visitor.continueTo = visitor.visit(poll); // 如果为true 停止遍历
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }
        }
    }

    /**
     * 前序遍历
     *
     * @param root    根
     * @param visitor 游客
     */
    protected void preorderTraversal(Node<T> root, Visitor<T> visitor) {
        if (root == null || visitor.continueTo) {
            return;
        }
        // root 节点
        visitor.continueTo = visitor.visit(root);
        // 前序遍历 左子树
        preorderTraversal(root.left, visitor);
        // 前序遍历 右子树
        preorderTraversal(root.right, visitor);

    }

    /**
     * 中序遍历
     *
     * @param root    根
     * @param visitor 游客
     */
    protected void inorderTraversal(Node<T> root, Visitor<T> visitor) {
        if (root == null || visitor.continueTo) {
            return;
        }
        inorderTraversal(root.left, visitor);
        if (visitor.continueTo) {
            return;
        }
        visitor.continueTo = visitor.visit(root);
        inorderTraversal(root.right, visitor);
    }

    /**
     * 后序遍历
     *
     * @param root    根
     * @param visitor 游客
     */
    protected void postorderTraversal(Node<T> root, Visitor<T> visitor) {
        if (root == null || visitor.continueTo) {
            return;
        }
        postorderTraversal(root.left, visitor);
        postorderTraversal(root.right, visitor);
        if (visitor.continueTo) {
            return;
        }
        visitor.continueTo = visitor.visit(root);
    }


    /**
     * 高度
     * 递归
     *
     * @param root 根
     * @return int
     */
    protected int height(Node<T> root) {
        if (root == null) {
            return 0;
        }
        return Math.max(height(root.left), height(root.right)) + 1;
    }

    /**
     * height 迭代
     *
     * @return int
     */
    protected int heightIteration() {
        Queue<Node<T>> queue = new LinkedList<>();
        queue.offer(root);
        int h = 0;  // 记录高度
        int levelSize = 1; // 记录当前层级元素剩余个数
        while (!queue.isEmpty()) {
            Node<T> poll = queue.poll();  // 当前层级元素出队
            levelSize--;
            if (poll.left != null) {
                queue.offer(poll.left);   // 把当前层级元素入队
            }
            if (poll.right != null) {
                queue.offer(poll.right);  // 把当前层级元素入队
            }
            if (levelSize == 0) {        // 如果当前层级元素出队完毕
                levelSize = queue.size();
                h++;
            }
        }
        return h;
    }

    @Override
    public Object root() {
        return root;
    }

    @Override
    public Object left(Object node) {
        return ((Node<T>) node).left;
    }

    @Override
    public Object right(Object node) {
        return ((Node<T>) node).right;
    }

    @Override
    public Object string(Object node) {
        return ((Node<T>) node).element;
    }

    /**
     * 元素not null检查
     *
     * @param element 元素
     */
    protected void elementNotNullCheck(T element) {
        if (element == null) {
            throw new IllegalArgumentException("element 不能为空");
        }
    }

    public static class Node<T> {
        T element;
        Node<T> left;       // 当前节点的左子节点
        Node<T> right;     // 当前节点的右子节点
        Node<T> parent;   // 当前节点的父节点


        public Node(T element, Node<T> parent) {
            this.element = element;
            this.parent = parent;
        }

        public Node() {

        }

        @Override
        public String toString() {
            return "Node{" +
                    "element=" + element +
                    '}';
        }

        public boolean hasTwoChildren() {
            return right != null && left != null;
        }

        public boolean isLeaf() {
            return right == null && left == null;
        }
    }


    public static abstract class Visitor<T> {
        /**
         * 访问
         * 返回false 继续遍历
         * 返回true 停止遍历
         *
         * @param node 节点
         * @return boolean
         */
        public abstract boolean visit(Node<T> node);

        public boolean continueTo = false;
    }
}
```





## BinarySearchTree

```java
public class BinarySearchTree<T> extends BinaryTree<T>  {

    private int size;
    public Node<T> root;
    private Comparator<T> comparator;


    public BinarySearchTree(Comparator<T> comparator) {
        this.comparator = comparator;
    }

    public BinarySearchTree() {
        this(null);
    }

    @Override
    public void add(T element) {
        elementNotNullCheck(element);

        // 1.初始化条件
        Node<T> temp = this.root;                      // 遍历的元素
        Node<T> parent = this.root;                   // 插入元素的父节点
        int compare = 0;                             // 记录插入位置
        Node<T> curr = new Node<>(element, parent); // 需要插入的元素

        // 2.找到父节点，以及插入位置
        // 2.a.判断根节点是否为空
        if (temp != null) {
            // 2.b.存在根节点，查找当前节点的父节点  parent.left/right = curr
            while (temp != null) {
                compare = compare(element, temp.element);
                parent = temp;
                if (compare > 0) {
                    temp = temp.right;
                } else if (compare < 0) {
                    temp = temp.left;
                } else {
                    temp.element = element;
                    return;
                }
            }
        } else {
            root = curr;
        }

        // 3.添加节点
        curr.parent = parent;
        if (compare > 0) {
            parent.right = curr;
        } else if (compare < 0) {
            parent.left = curr;
        }
        size++;

    }

    @Override
    public Node<T> getNodeForElement(T element) {
        return getNodeUseIteration(element);
    }

    /**
     * 得到节点使用迭代
     *
     * @param element 元素
     * @return {@link Node<T>}
     */
    private Node<T> getNodeUseIteration(T element) {
        if (element == null || root == null) {
            return null;
        }

        Node<T> temp = this.root;
        while (temp != null) {
            Integer d = compare(element, temp.element);
            if (d == 0) {
                return temp;   // 返回节点
            }
            if (d > 0) {
                temp = temp.right;
            } else {
                temp = temp.left;
            }
        }
        return null;
    }

    /**
     * 比较
     *
     * @param element 需要添加的元素
     * @param compare 比较的对象
     * @return {@link Integer}
     * 返回0 表示相等         覆盖
     * 大于0 表示element大    右边
     * 小于0 表示compare大    左边
     */
    private Integer compare(T element, T compare) {
        if (comparator == null) {
            return ((Comparable<T>) element).compareTo(compare);
        }
        return comparator.compare(element, compare);
    }
}
```





# 平衡二叉树

当节点数量固定，左右子树高度越接近，这课二叉树就越平衡



## 二叉搜索树如何改进？

1. 节点的添加、删除顺序是无法限制的
2. 在节点添加、删除操作之后，想办法让二叉树恢复平衡。
3. 用尽量少的调整次数，达到适度平衡

![image-20201218101120831](C:%5CUsers%5Cpdd20%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201218101120831.png)



## 常见的平衡二叉搜索树

- AVL树
  - Windows NT内核中广泛使用
- 红黑树
  - Java中TreeMap、TreeSet、HashMap、HashSet
- linux的进程调度





# AVL树

- 平衡因子：某节点的左右子树的高度差
- AVL树的平衡因子：1、0、-1
- 每个节点的平衡因子高度差不超过1

![image-20201218102041024](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218102041.png)



## 添加导致的失衡

- 最坏情况：可能会导致所有祖先节点都失衡
- 父节点，非祖父节点都不会失衡

![image-20201218102852134](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218102852.png)



### LL-右旋转(单旋)

![image-20201218104127383](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218104127.png)



### RR-左旋转(单旋)

![image-20201218104241922](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218104242.png)



### LR-RR左旋转，LL右旋转(双旋)

![image-20201218104536999](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218104537.png)

### RL-LL右旋转，RR左旋转

![image-20201218105350939](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218105351.png)



## 代码实现

### 1.添加2个方法在BinarySerachTree，方便扩展

![image-20201218131209072](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218131209.png)

![image-20201218131253850](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201218131253.png)



### AVLTree实现addAfter()

```java
@Override
protected void addAfter(Node<T> node) {
    // 1.找到最近的失衡节点
    while ((node = node.parent) != null) {
        if (isBalance((node))) {        // 判断当前节点是否是平衡的
            // 更新高度
            updateHeight(node);
        } else {
            // 恢复平衡
            toRestoreBalance(node);
            break;
        }
    }
}


/**
* 是否平衡
*
* @param node 当前节点
* @return boolean
*/
private boolean isBalance(Node<T> node) {
    return Math.abs(((AVLNode<T>) node).balanceFactor()) <= 1;  // 调用avlNode中的balanceFactor()方法
}


/**
* 更新高度
*
* @param node 节点
*/
private void updateHeight(Node<T> node) {
    ((AVLNode<T>) node).updateHeight();  // 调用avlNode中的updateHeight()方法
}

```







### 恢复平衡代码

通过判断节点是不是左或右节点

```java
/**
 * 恢复平衡
 *
 * @param grand 祖父节点
 */
private void toRestoreBalance(Node<T> grand) {
    Node<T> parent = ((AVLNode<T>) grand).tallerChild();
    Node<T> node = ((AVLNode<T>) parent).tallerChild();

    if (parent.isLeftChild()) {        // l
        if (node.isLeftChild()) {     // ll  - 右旋转
            rightRotation(grand);
        } else {                    // lr  左旋转 -> 右旋转
            leftRotation(parent);
            rightRotation(grand);
        }
    } else {                         // l
        if (node.isRightChild()) {  // rr 左旋转
            leftRotation(grand);
        } else {                   // rl 右旋转 -> 左旋转
            rightRotation(parent);
            leftRotation(grand);
        }
    }
}



public boolean isLeftChild() {
    return parent != null && this == parent.left;
}

public boolean isRightChild() {
    return parent != null && this == parent.right;
}
```





### 左旋转和右旋转代码

```java
/**
 * 右旋转
 *
 * @param grand 节点
 */
private void rightRotation(Node<T> grand) {
    Node<T> parent = grand.left;
    Node<T> root = grand.parent;
    Node<T> t2 = parent.right;

    grand.left = parent.right;
    parent.right = grand;
    // 更新父节点
    afterRo(grand, parent, root, t2);
}

/**
 * 左旋转
 *
 * @param grand 节点
 */
private void leftRotation(Node<T> grand) {
    Node<T> parent = grand.right;
    Node<T> root = grand.parent;
    Node<T> t1 = parent.left;

    // 交换位置 连线
    grand.right = parent.left;
    parent.left = grand;

    afterRo(grand, parent, root, t1);
}

/**
 * 旋转之后调整父节点的位置
 *
 * @param grand  大
 * @param parent 父
 * @param root   根
 * @param child   parent的子节点
 */
private void afterRo(Node<T> grand, Node<T> parent, Node<T> root, Node<T> child) {
    // 更新root节点的子节点
    if (grand.isLeftChild()) {
        root.left = parent;
    } else if (grand.isRightChild()) {
        root.right = parent;
    } else {   // root
        this.root = parent;
    }

    // 更新父节点
    parent.parent = root;
    if (child != null) {
        child.parent = grand;
    }
    grand.parent = parent;

    // 更新高度
    updateHeight(grand);
    updateHeight(parent);
}
```

### 新建AVLNode类

```java
private static class AVLNode<T> extends Node<T> {
    int height = 1; // 当前节点的高度

    public AVLNode(T element, Node<T> parent) {
        super(element, parent);
    }

    /**
     * 计算当前节点的平衡因子
     *
     * @return int
     */
    public int balanceFactor() {
        int leftH = left == null ? 0 : ((AVLNode<T>) left).height;
        int rightH = right == null ? 0 : ((AVLNode<T>) right).height;
        return leftH - rightH;
    }

    /**
     * 找到最高的子节点
     *
     * @return {@link AVLNode<T>}
     */
    public Node<T> tallerChild() {
        int leftH = left == null ? 0 : ((AVLNode<T>) left).height;
        int rightH = right == null ? 0 : ((AVLNode<T>) right).height;
        if (rightH > leftH) return right;
        if (rightH < leftH) return left;
        return isLeftChild() ? left : right;
    }

    /**
     * 更新当前节点的高度
     */
    private void updateHeight() {
        int leftH = left == null ? 0 : ((AVLNode<T>) left).height;
        int rightH = right == null ? 0 : ((AVLNode<T>) right).height;
        height = Math.max(leftH, rightH) + 1;
    }

    @Override
    public String toString() {
        return "AVLNode{" +
                "height=" + height +
                ", element=" + element +
                '}';
    }
}
```





## 一个统一的旋转操作

![image-20201219100149283](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201219100156.png)

```java
/**
 * 统一的旋转
 *
 * @param grand 大
 * @param d     d
 * @param a     a
 * @param b     b
 * @param c     c
 * @param e     e
 * @param f     f
 * @param g     g
 */
private void rotation(Node<T> grand,
                      Node<T> a, Node<T> b, Node<T> c,
                      Node<T> d,
                      Node<T> e, Node<T> f, Node<T> g) {
    d.parent = grand.parent;
    if (grand.isRightChild()) {
        grand.parent.right = d;
    } else if (grand.isLeftChild()) {
        grand.parent.left = d;
    } else {
        root = d;
    }

    doIt(a, b, c);
    doIt(e, f, g);
    doIt(b, d, f);
}

private void doIt(Node<T> a, Node<T> b, Node<T> c) {
    b.left = a;
    b.right = c;
    if (a != null) {
        a.parent = b;
    }
    if (c != null) {
        c.parent = b;
    }
    updateHeight(b);
}
```

![image-20201219205245627](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201219205245.png)





## 删除导致的失衡



### LL-右旋转

![image-20201220101739342](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220101746.png)

![image-20201220102037659](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220102037.png)

### RR-左旋转

![image-20201220102053825](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220102054.png)



### LR-RL 左旋转 右旋转

![image-20201220102118611](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220102118.png)



### RL-LL 右旋转，左旋转

![image-20201220102205446](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220102205.png)





### 代码实现

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220104044.png)

![image-20201220104059791](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220104059.png)





## 总结

![image-20201220105206401](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220105206.png)





# 红黑树

## 特性

红黑树也是一种自平衡的二叉搜索树(也叫平衡二叉B树)

1. 节点是==RED==或者**BLACK**
2. 根节点必须是**BLACK**
   1. 叶子节点(n0)都是**BLACK**，如果叶子是==RED==，就新加2个**BLACK**且为null
3. ==RED==节点的子节点都是**BLACK**
   1. ==RED==节点的Parent都是**BLACK**
   2. 从根节点 n0的所有路径上不能有2个连续的==RED==节点
4. 从任意一节点到n0(==为补充的null==)的所有路径的**BLACK**节点的数量的都相同



## 判断这个树是不是红黑树

不是，因为这个位置还有一个需要补充。补充完之后就不是了

![image-20201221094404595](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221094411.png)

## 红黑树的等价变化

- 红黑树和4阶B树具有等价性
- **BLACK**节点和他的`RED`子节点融合在一起，可以形成一个B树节点
  - 即有多少个**BLACK**节点就有多少个B树节点
  - 下图忽略了NULL节点

![image-20201221101238236](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221101238.png)



## 术语

1. parent：父节点
2. sibling：兄弟节点，**同一个父节点的子节点**
3. uncle：叔叔节点，**父节点是兄弟节点**
4. grand：父节点的父节点



以33为例

- 25是父节点
- 17是兄弟节点
- 46是叔叔节点
- 38是grand

![image-20201221101920405](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221101920.png)



## 一些辅助函数

### RBTree

~~~java
/**
* 红黑树的节点
*
* @param <T>
*/
private static class RBNode<T> extends Node<T> {
    /**
* 当前节点的颜色 red or black
*/
    boolean color;

    public RBNode(T element, Node<T> parent) {
        super(element, parent);
    }
}


/**
* 给节点染色
*
* @param node  节点
* @param color 颜色
*/
private Node<T> color(Node<T> node, boolean color) {
    if (node == null) {return null;}
    ((RBNode<T>) node).color = color;
    return node;
}

private Node<T> toRed(Node<T> node) {
    return color(node, RED);
}

private Node<T> toBlack(Node<T> node) {
    return color(node, BLACK);
}

/**
* 查看节点的颜色
* 如果节点是null则返回黑色
*
* @param node 节点
* @return boolean
*/
private boolean colorOf(Node<T> node) {
    return node == null ? BLACK : ((RBNode<T>) node).color;
}

private boolean isRed(Node<T> node) {
    return colorOf(node) == RED;
}

private boolean isBlack(Node<T> node) {
    return colorOf(node) == BLACK;
}

~~~





### BinaryTree.Node

~~~java
public Node<T> sibling() {
    if (isLeftChild()) {
        return parent.right;
    }
    if (isRightChild()) {
        return parent.left;
    }
    return null;
}

public Node<T> uncle() {
    return parent.sibling();
}
~~~





## 添加

 添加必然添加到最后一层，共12种情况如下图：

![image-20201221111932359](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221111932.png)



### 添加-修复特性4-LL/RR



![image-20201221113503324](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221113503.png)





### 添加-修复特性4-LR/RL



![image-20201221113856631](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221113856.png)





### 添加-修复特性4- 上溢 LL

![image-20201221114834289](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221114834.png)

![image-20201221114938968](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221114939.png)



### 添加-修复特性4- 上溢 RR

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221115115.png)





### 添加-修复特性4- 上溢 LR

![image-20201221115214804](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221115215.png)

### 添加-修复特性4- 上溢 RL

![image-20201221115551317](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201221115551.png)









### 代码

```java
/**
 * 添加后恢复成红黑树
 *
 * @param node 节点
 */
@Override
protected void addAfter(Node<T> node) {
    Node<T> parent = node.parent;
    Node<T> grand = node.grand();
    Node<T> uncle = node.uncle();

    // 1.添加的是根节点 或 上溢到达了根节点
    if (parent == null) {
        toBlack(node);
        return;
    }

    // 2.如果父节点是黑色，直接返回
    if (isBlack(parent)) { return; }

    // 3.判断uncle是不是red
    if (isRed(uncle)) {   // 红色，上溢
        // 3.1、parent和uncle染成黑色
        toBlack(parent);
        toBlack(uncle);
        // 3.2、grand向上合并(当做是新添加的节点)
        addAfter(toRed(grand));
    } else {         // 不是红色
        // 旋转
        if (parent.isLeftChild()) {
            if (node.isLeftChild()) {  // LL
                toBlack(parent);
                toRed(grand);
                rightRotation(grand);
            }else {  // LR
                toBlack(node);
                toRed(grand);
                leftRotation(parent);
                rightRotation(grand);
            }
        }else {
            if (node.isRightChild()) {  //RR
                toBlack(parent);
                toRed(grand);
                leftRotation(grand);
            }else { // RL
                toBlack(node);
                rightRotation(parent);
                toRed(grand);
                leftRotation(grand);
            }
        }
    }
}
```







## 删除

在B树中，真正被删除的都是叶子节点n0

1. 删除是==RED==不用做任何处理

2. 删除**BLACK**节点

   - 拥有2个`red`子节点 

     - 不存在

   - 拥有一个`red`子节点

     - 判断条件：子节点是`RED`
     - 将子节点染黑

3. 删除的**BLACK**没有子节点

  1. sibling是**BLACK**

     1. 如果sib至少有一个`RED`节点

        1. 旋转 LR RL  RR LL
        2. sib的子节点为root节点(颜色为parent的颜色)
        3. parent为sib.son的子节点
        4. sib和parent都为black

        ![image-20201222104829242](C:%5CUsers%5Cpdd20%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201222104829242.png)


  2. sib是`RED`

     ![image-20201222110733454](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201222110733.png)

     

  3. sib没有`RED`子节点


     1. parent是红色


        1. sib染成`RED` 
        2. parent染成**BLACK**

        ![image-20201222105444201](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201222105444.png)

     2. 如果parent本来就是black


        1. 会导致parent下溢
        2. 把parent当做新删除的节点->递归调用



### 代码

```java
/**
 * 删除后恢复成红黑树
 *
 * @param node 节点
 */
@Override
protected void removeAfter(Node<T> node) {
    Node<T> son = node.left != null ? node.left : node.right;
    Node<T> parent = node.parent;


    // 1.要删除的是RED->直接删除
    if (isRed(node)) { return; }

    // 2. 要删除的是n1,子节点是BLACK(n2这种情况不存在)
    if (isRed(son)) {
        toBlack(son); // 将子节点染黑
        return;
    }

    // 3.删除是n0,BLACK节点(红黑树默认补null为BLACK)
    if (parent == null) {return;}   // root是null->直接返回
    boolean isLeft = parent.left == null || node.isLeftChild();
    Node<T> sib = isLeft ? parent.right : parent.left;

    if (isLeft) {   // L
        if (isRed(sib)) {  // 把红色兄弟换成黑色兄弟
            toBlack(sib);
            toRed(parent);
            leftRotation(parent);
            // 更换兄弟
            sib = parent.right;
        }
        // 兄弟节点是黑色
        if (isBlack(sib.right) && isBlack(sib.left)) {
            // 兄弟都是黑色子节点
            boolean color = isBlack(parent);
            toRed(sib);
            toBlack(parent);
            if (color) { // 如果父亲本来就是黑色，就会产生下溢
                removeAfter(parent);
            }
        } else {// 兄弟至少有一个RED子节点
            if (isBlack(sib.right)) { // 左边是黑色 兄弟进行旋转
                rightRotation(sib);
                sib = parent.right;
            }
            color(sib, colorOf(parent));
            toBlack(sib.right);
            toBlack(parent);
            leftRotation(parent);
        }
    } else {  // R
        if (isRed(sib)) {  // 把红色兄弟换成黑色兄弟
            toBlack(sib);
            toRed(parent);
            rightRotation(parent);
            // 更换兄弟
            sib = parent.left;
        }
        // 兄弟节点是黑色
        if (isBlack(sib.left) && isBlack(sib.right)) {
            // 兄弟都是黑色子节点
            boolean color = isBlack(parent);
            toRed(sib);
            toBlack(parent);
            if (color) { // 如果父亲本来就是黑色，就会产生下溢
                removeAfter(parent);
            }
        } else {// 兄弟至少有一个RED子节点
            if (isBlack(sib.left)) { // 左边是黑色 兄弟进行旋转
                leftRotation(sib);
                sib = parent.left;
            }
            color(sib, colorOf(parent));
            toBlack(sib.left);
            toBlack(parent);
            rightRotation(parent);
        }
    }
}
```







# AVL和RB树的对比

![image-20201222144718638](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201222144718.png)

# B树

b树是一种平衡的多路搜索树，多用于文件系统、数据库的实现

1. 1个节点可以存储超过2个元素，可以用有超过2个子节点
2. 大的在右边，小的在左边
3. 平衡
4. 很矮

**3阶**

子节点最多3个

![image-20201220110927970](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220110928.png)



**4阶**

子节点最多4个

![image-20201220110944988](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220110945.png)



## 性质

m阶B树的性质

1. 假设一个节点存储的元素个数为x
   1. 根节点  1<=x<=m-1
   2. 非根节点：![image-20201220111230342](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220111230.png)
   3. 如果有子节点 ，则个数为y=x+1
      1. 根节点：2<=y<=m
      2. 非根节点：![image-20201220112522083](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220112522.png)

![image-20201220112803780](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220112803.png)

![image-20201220112913008](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220112913.png)



## B树vs二叉搜索树

![image-20201220113442619](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220113442.png)



## 搜索

![image-20201220113712870](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220113713.png)





## 添加



### 上溢

![image-20201220114410754](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220114411.png)

![image-20201220114555338](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220114555.png)







## 删除



### 叶子节点

![image-20201220114617495](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220114617.png)



### 非叶子节点

![image-20201220114941619](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220114941.png)





### 下溢

![image-20201220115700489](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201220115700.png)