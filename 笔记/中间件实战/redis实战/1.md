

.\redis-server.exe .\redis.windows-service.conf



# 1.redis生产环境启动方案

![image-20210425203616979](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210425203617.png)

![image-20210425203812659](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210425203812.png)





# 2.redis持久化对于生产环境中灾难恢复的意义



1.redis持久化 RDB,AOF区别，各自的特点是什么，适合什么场景

2.redis突然挂掉了，进程死了，或者所在的机器没了，反正遇到灾难性的故障，redis挂了。存放的数据全都没了，很惨，很重要的缓存数据，服务了很多重要的系统和服务。redis会重启，重启之后，需要费很大的劲去恢复redis。redis如果单单存放在内存中，是没有任何办法应对一些灾难性的故障的。





# 3.分析Redis的RDB和AOF两种持久化机制的工作原理

持久化主要是为了灾难恢复，数据恢复，也可以归类到高可用的一个环节中

## RDB

对redis中的数据执行周期性的持久化(每隔一段时间生成redis内存中的数据的一份完整快照)，





## AOF

**AOF文件是存放每条写命令的**

操作系统会有一个os cache，写文件不会直接写入磁盘，会先往os cache中写入，然后到一定时间在从os cache到disf file

AOF是每隔一段时间调用一次操作系统的fsync操作，强制将os cache中的数据刷入磁盘文件中。

redis中的数据是有一定限量的，不可能无限增长，导致AOF文件无限增长。到一定时候redis就会用缓存淘汰算法比如说LRU，删除一些数据

到AOF文件大到一定时候，AOF就会做rewrite(不是基于已存在的AOF文件，而是当时redis的状态)操作，会基于redis内存中的数据，来重新构造一个更小的AOF文件





## 对比

如果同时使用RDB和AOF两种持久化数据，在redis重启的时候或优先使用AOF文件来重构数据，因为数据更加完整



**RDB优点**

1. RDB会生成多个数据文件，每个数据文件都代表了某一时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件，发送到一些远程的安全存储服务上去。
2. 对redis对外提供的读写服务，影响非常下，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘io操作来进行rdb持久化即可
3. 相对AOF持久化来说，直接基于RDB来重启和回复redis更快



**RDB缺点**

1. RDB生成数据快照一般是5分钟，或者更长，这个时候宕机，那么就丢失了5分钟的数据
2. 如果RDB在fork子进程来执行RDB的时候，如果文件特别大，可能会导致服务暂停数毫秒，甚至数秒。所以RDB间隔不能特别大



**AOF优点**

1. aof更好的保护数据不丢失，一般aof会每隔1秒进行一次fsync操作，最多丢失1秒的数据
2. 使用append-only写入，不会有磁盘寻址的开销，写入性能高，不容易被破坏
3. rewrite是对新老文件一起写入，然后进行merge
4. aof是以记录命令的方式进行的，可以查看所有的操作记录，防止flushall的破坏操作





**AOF缺点**

1. AOF文件更大
2. 性能有降低
3. AOF可能有bug，不能恢复出一模一样的数据
4. 数据恢复的时候比较慢，不方便，可能需要自己写脚本



![image-20210426210731824](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210426210739.png)





# 4.redis的RDB持久化配置以及数据恢复实验

配置RDB持久化操作：

~~~bash
save 60 1000
~~~

可以设置多个

每隔60s,如果有超过1000个key发生了变化，就新生成一个dump.rdb文件，就是当前redis内存中的完整数据的快照(snapshotting)，也可以手动调用save 或者 bgsave，同步或异步执行rdb快照生成。



## 关闭测试：

~~~
shutdown
~~~

使用之后，会在关闭直接保存redis数据

~~~~
异常关闭，比如kill -9
~~~~

使用之后，不会保存数据





# 5.深入讲解redis的AOF持久化的各种操作和相关实验

AOF默认是关闭的

~~~bash
appendonly yes
~~~

打开aof持久化机制，在生产环境中一般来说AOF是要打开的，除非说随便丢个几分钟数据都无所谓。

打开AOF之后，redis每次接受到一条命令后，就会写入日志文件中，当然先写入os cache中，然后每隔一段时间 fsync中，如果AOF和RDB都开启了，优先通过AOF文件恢复数据。

**fsync策略有3种**

~~~
always:每次写入一条数据，立即执行fsync
	mysql：内存策略，大量磁盘，qps一般 1 - 2K
	redis：内存，磁盘持久化 qps 单机 一般 1w+ 没问题
everysec:每秒将os cache中的数据fsync到磁盘，一般都这么配置
no:redis仅仅将数据写入os chache就不管了，靠os自己的策略掉用fsync
~~~



## 测试

![image-20210427214935191](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210427214958.png)

![image-20210427214940080](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210427215002.png)

可以看到在appendonly.aof文件中，可以看到刚刚的命令日志，他们其实就是先写入到os cache的，然后1秒后调用fsync写入到aof文件中.

kill _ 9后，数据也恢复了

![image-20210427215236004](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210427215236.png)_



## rewrite

redis中的数据可能是优先的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉。

redis中的数据会不断的淘汰，只有一些常用的数据会被自动保留在redis内存中。

所以一些已经被淘汰的数据会存在于aof文件中，aof文件就一个，会不断的变大，很大。

所以aof会自动在后台每隔一段时间进行rewrite操作，比如日志里面已经存放了100w数据的写日志；redis内存只剩10w数据，基于内存中当前10w数据构建一套最新的日志，覆盖老的aof文件，确保aof文件不会过大，保持跟redis内存数据量一致。

redis2.4之前，还需要手动调用 BGREWRITEAOF 命令执行aof rewrite



**rewrite相关配置**

redis会记录上次rewrite文件的大小，如果超过上次aof文件percentage的百分比大小就进行rewrite

min-size：最小这么大才进行rewrite

~~~
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
~~~

比如上次是128mb，如果现在是256mb，就会触发rewrite，但是还要确认min-size。



**rewrite步骤**

~~~
1.redis fork一个子进程
2.子进程基于当前redis内存中的数据，构建一个新的aof文件
3.redis主线程，在收到客户端的写操作之后，在内存中写入操作记录，并写入旧的aof文件
4.子进程写完新数据后，redis主进程也会将内存中的新的日志追加到新的aof文件中
5.用新的aof文件替换旧的
~~~



## aof和rdb同时工作

~~~
如果rdb在执行snapshotting操作，那么redis不会执行aof的rewrite操作。
如果在执行aof rewrite操作， 那么就不会执行rdb snapshotting。
如果在执行rdb snapshotting，用户调用了BGREWRITEAOF命令，那么等rdb操作完了之后就会执行aof操作
如果同时有aof文件和rdb文件，那么redis重启的时候会使用aof文件进行数据恢复
~~~

如果aof有部分数据，rdb也有部分数据。但是redis重启的时候，不会加载rdb中的数据

