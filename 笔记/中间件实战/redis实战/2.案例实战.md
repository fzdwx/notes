此笔记对应代码在

~~~
代码/actualCombat/redis-actualCombat/src/main/java/cn/like/redis/testCase
~~~





# 0.redis 连接

~~~java
package cn.like.redis.testCase;

import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisURI;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.reactive.RedisReactiveCommands;

import java.time.Duration;
import java.time.temporal.ChronoUnit;

/**分布式锁
 * redis 连接程序
 *
 * @author like
 * @date 2021-05-05 13:46
 */
public class Redis {

    private Redis() {
    }

    public static RedisReactiveCommands<String, String> cmd() {
        RedisURI uri = RedisURI.builder()
                .withHost("localhost")
                .withPort(6379)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        RedisClient redisClient = RedisClient.create(uri);
        StatefulRedisConnection<String, String> connect = redisClient.connect();

        RedisReactiveCommands<String, String> cmd = connect.reactive();

        while (true) {
            if (cmd.isOpen()) {
                return cmd;
            }
        }
    }
}
~~~





# 1.案例实战：最普通的基于Redis实现的缓存机制

~~~
set
~~~



比如说，一个很复杂的查询，就可以用redis作为缓存

~~~java
public class 普通的基于redis的缓存_01 {
    private static final Logger log = LoggerFactory.getLogger(普通的基于redis的缓存_01.class);

    public static void main(String[] args) {
        redisCmd().set("hello", "world").block();

        redisCmd().get("hello").subscribe(v -> {
            log.info("[main] [hello]: {}", v);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 2.案例实战：实现一个最简单的分布式锁

~~~
set nx ex
~~~



~~~java
public class 实现一个最简单的分布式锁_02 {

    private final static Logger log = LoggerFactory.getLogger(实现一个最简单的分布式锁_02.class);

    public static void main(String[] args) {
        int count = 0;
        String lock = "lock_test";

        // 第一次加锁
        count = lock(count, lock);

        // 第二次加锁
        count = lock(count, lock);
        // 删除lock
        cmd().del(lock).block();

        // 第三次加锁
        lock(count, lock);

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static int lock(int count, String lock) {
        String res = cmd().set(lock, String.valueOf(++count), SetArgs.Builder.ex(100).nx())
                .block();

        System.out.println("[main] [第  " + count + " 次 加锁 ]" + res);
        return count;
    }
}
~~~





# 3.案例实战：实现博客网站的文章发布与查看

~~~bash
mset
mget
msetnx

m -> multi ，多个

相当于batch批量的设置和查询。
~~~



~~~java
public class 实现博客网站的文章发布与查看_03 {
    private final static Logger log = getLogger(实现博客网站的文章发布与查看_03.class);

    public static void main(String[] args) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");

        // 存
        HashMap<String, String> map = new HashMap<>(16);
        map.put("article:1:title", "学习使用redis");
        map.put("article:1:content", "实现博客网站的文章发布与查看");
        map.put("article:1:author", "like");
        map.put("article:1:time", sdf.format(new Date()));

        String res = cmd().mset(map).block();

        System.out.println(res);

        // 取
        Flux<KeyValue<String, String>> flux = cmd().mget("article:1:title");
        KeyValue<String, String> s = flux.blockLast();
        System.out.println(s);

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}



# 4.实现博客字数统计与文章预览

​~~~bash
strlen				# 获取指定key的长度
grange 				# 获取 指定长度的数据  start offset
~~~



~~~java
public class 实现博客字数统计与文章预览_04 {

    public static void main(String[] args) {
        cmd().mget("article:1:title", "article:1:content", "article:1:author", "article:1:time")
                .subscribe(kv -> {
                    // 一条一条的消费
                    kv.map(s -> {
                        System.out.println(s);
                        return true;
                    });
                });

        // strlen
        cmd().strlen("article:1:content").subscribe(res -> {
            System.out.println("博客长度:" + res);
        });
        // getrange
        cmd().getrange("article:1:content", 0, 11).subscribe(res -> {
            System.out.println("博客预览:" + res);
        });
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 5.实现用户操作日志审计功能

~~~bash
append
~~~



把用户在系统里面的操作记录下来，每一条操作都记录成一条日志。后续可以通过一个列表来进行查询，分页查询。如果说要记录redis来存储这种操作审计日志，应该如何来做？

也可以在redis中存一个key，每天都有一个key，每天的这个key里面就把当天所有的操作日志都串联起来，查询的时候，都是按天来查询你的操作审计日志。

key -> value,value 字符串拼接

append可以不停把日志追加到指定的key



~~~java
public class 实现用户操作日志审计功能_05 {

    public static void main(String[] args) {
        String now = DateUtil.now();
        String key = "operation_log_"+ now;
        cmd().setnx(key, "").block();

        for (int i = 1; i < 10; i++) {
            cmd().append(key, "今天的第" + (i) + "条操作日志\n").block();
        }

        cmd().get(key).subscribe(System.out::println);

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~



# 6.实现一个简单的唯一ID生成器

一般都是通过数据库的自增主键来实现的，在一些场景下，分库分表，同一个表的数据都会分散在多个库的多个表里面，这个时候就不是光靠数据库来生成自增长的主键，就需要当前的功能了

snowflake算法，还有一些开源大厂的唯一id生成组件。

~~~
incr 
~~~



# 7.实现博客点赞次数计数器

~~~
incr
~~~



```java
public class 实现博客点赞次数计数器_07 {

    public static void main(String[] args) {
        cmd().incr("article:1:goodCount");
    }
}
```





# 8.实现社交网站的网址点击追踪机制（短链接）

~~~
hset
hget
hincrby
~~~



社交网站一般会把你发表的一些微博里面的**长链接**转换为**短链接**，这样可以利用短链接进行点击数量追踪，然后再让你进入短链接对应的长连接地址里面，

http://qwe.cn/ASDZsdg -> http://redos.com/index.html

利用redis的incr自增长，然后10进制转36进制，然后hset存放在hash数据结构里面，在提供一个映射转换的hget获取方法

~~~java
public class 实现社交网站的网址点击追踪机制_08 {

    public static final String X36 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    public static final String[] X36_ARRAY = X36.split("");

    /** 根据当前seed生成短链接 越大越看不懂 */
    private static final String KEY_SHORT_URL_SEED = "SHORT_URL_SEED";
    /**
     * 短连接访问次数
     * SHORT_URL_ACCESS_COUNT:{
     *  https://like.com/97G78 : 156
     *  https://like.com/6gQDf : 334
     * }
     */
    private static final String KEY_SHORT_URL_ACCESS_COUNT = "SHORT_URL_ACCESS_COUNT";
    /**
     * 长短 url映射
     * URL_MAPPING:{
     *  https://like.com/97G78 :https://apppukyptrl1086.pc.xia123oe-tech.com
     * }
     */
    private static final String KEY_URL_MAPPING = "URL_MAPPING";
    /** 网络前缀 */
    private static final String WEB_PREFIX = "https://like.com/";

    /**
     * 得到短url
     *
     * @param url url
     * @return {@link String}
     */
    public String getShortUrl(String url) {
        Long shortUrlSeed = cmd().incr(KEY_SHORT_URL_SEED).block();

        StringBuilder sb = new StringBuilder();

        if (shortUrlSeed == null || shortUrlSeed == 0) {
            shortUrlSeed = 0L;
            sb.append("0");
        }

        // 转换为36进制
        while (shortUrlSeed > 0) {
            sb.append(X36_ARRAY[(int) (shortUrlSeed % 36L)]);
            shortUrlSeed = shortUrlSeed / 36;
        }

        sb.reverse();
        String shortUrl = sb.insert(0, WEB_PREFIX).toString();

        cmd().hset(KEY_SHORT_URL_ACCESS_COUNT, shortUrl, "0").subscribe();
        cmd().hset(KEY_URL_MAPPING, shortUrl, url).subscribe();

        return shortUrl;
    }

    /**
     * 增加 shortUrl 的访问次数
     *
     * @param shortUrl 短网址
     */
    public void incrementShortURLAccessCount(String shortUrl) {
        cmd().hincrby(KEY_SHORT_URL_ACCESS_COUNT, shortUrl, 1).subscribe();
    }

    /**
     * 增加 shortUrl 的访问次数
     *
     * @param shortUrl 短网址
     */
    public Long getShortURLAccessCount(String shortUrl) {
        return Long.valueOf(cmd().hget(KEY_SHORT_URL_ACCESS_COUNT, shortUrl).block());
    }
}
~~~





## test

~~~java
public static void main(String[] args) {
    实现社交网站的网址点击追踪机制_08 test = new 实现社交网站的网址点击追踪机制_08();
    String shortUrl = test.getShortUrl("https://apppukyptrl1086.pc.xia123oe-tech.com");
    System.out.println("短链接为:" + shortUrl);

    for (int i = 0; i < 133; i++) {
        test.incrementShortURLAccessCount(shortUrl);
    }
    System.out.println("访问次数" + test.getShortURLAccessCount(shortUrl));
}
~~~



![image-20210505183705100](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183816.png)

![image-20210505183711006](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183823.png)

![image-20210505183716066](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183818.png)





# 9.案例实战：对博客网站案例代码进行重构

博客网站，发布一篇文章，修改一篇文章，查看一篇文章，有人查看了一下这篇文章，就可以维护一下他的浏览次数，对于这个浏览次数就都可以统一放在一个hash数据结构里面。

==key就是文章编号,field就是博客的字段，value就是字段对应的==

~~~java
public class 对博客网站案例代码进行重构_09 {
    public static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");

    /**
     * 发布博客
     *
     * @param title   标题
     * @param content 内容
     * @param author  作者
     * @param time    时间
     * @return boolean
     */
    public Mono<String> publishBlog(String id, String title, String content, String author, Date time) {
        Map<String, String> map = new HashMap<>(8);
        map.put(FIELD_ID, id);
        map.put(BlogHelper.FIELD_TITLE, title);
        map.put(BlogHelper.FIELD_CONTENT, content);
        map.put(BlogHelper.FIELD_AUTHOR, author);
        map.put(BlogHelper.FIELD_TIME, sdf.format(time));
        map.put(BlogHelper.FIELD_VIEW_COUNT, String.valueOf(0));
        map.put(BlogHelper.FIELD_LIKE_COUNT, String.valueOf(0));
        map.put(BlogHelper.FIELD_CONTENT_LENGTH, String.valueOf(content.length()));
        // reactor 设置blog信息后，获取博客内容长度

        reactive().incr( KEY_BLOG_COUNT).subscribe();
        return reactive().hmset(KEY_ARTICLE_PREFIX(id), map);
    }

    /**
     * 发布博客
     *
     * @param blog 博客
     * @return
     */
    public Mono<String> publishBlog(Blog blog) {
        return publishBlog(blog.getId(), blog.getTitle(), blog.getContent(), blog.getAuthor(), blog.getTime());
    }

    /**
     * 更新博客
     *
     * @param id      id
     * @param title   标题
     * @param content 内容
     * @param author  作者
     * @param time    时间
     * @return
     */
    public Mono<String> updateBlog(String id, String title, String content, String author, Date time) {
        HashMap<String, String> map = new HashMap<>(4);
        if (StrUtil.isNotBlank(title))
            map.put(FIELD_TITLE, title);
        if (StrUtil.isNotBlank(content)) {
            map.put(FIELD_CONTENT, content);
            map.put(FIELD_CONTENT_LENGTH, String.valueOf(content.length()));
        }
        if (StrUtil.isNotBlank(author))
            map.put(FIELD_AUTHOR, author);
        if (StrUtil.isNotBlank(time.toString()))
            map.put(FIELD_TIME, sdf.format(time));
        return reactive().hmset(KEY_ARTICLE_PREFIX(id), map);
    }

    /**
     * 更新博客
     *
     * @param blog 博客
     * @return
     */
    public Mono<String> updateBlog(Blog blog) {
        return updateBlog(blog.getId(), blog.getTitle(), blog.getContent(), blog.getAuthor(), blog.getTime());
    }

    /**
     * 博客
     *
     * @param id id
     * @return {@link Blog}
     */
    public Flux<List<KeyValue<String, String>>> getBlog(String id) {
        return reactive().hgetall(KEY_ARTICLE_PREFIX(id)).buffer();
    }

    /**
     * 点赞博客
     *
     * @param id id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> likeBlog(String id) {
        return reactive().hincrby(KEY_ARTICLE_PREFIX(id), FIELD_LIKE_COUNT, BlogHelper.ADD_ONE);
    }

    /**
     * 取消 点赞博客
     *
     * @param id id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> cancelLikeBlog(String id) {
        return reactive().hincrby(KEY_ARTICLE_PREFIX(id), FIELD_LIKE_COUNT, BlogHelper.SUB_ONE);
    }

    /**
     * 浏览 博客
     *
     * @param id id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> incrViewBlogCount(String id) {
        return reactive().hincrby(KEY_ARTICLE_PREFIX(id), FIELD_VIEW_COUNT, ADD_ONE);
    }

    /**
     * 博客 助手
     *
     * @author pdd20
     */
    public static class BlogHelper {
        // ================ blog 存储在redis的key ================
        public static final String ARTICLE_PREFIX = "article:";
        public static final String KEY_BLOG_COUNT = "article:count";
        public static final String FIELD_ID = "ID";
        public static final String FIELD_TITLE = "title";
        public static final String FIELD_CONTENT = "content";
        public static final String FIELD_AUTHOR = "author";
        public static final String FIELD_TIME = "time";
        public static final String FIELD_CONTENT_LENGTH = "content_length";
        public static final String FIELD_VIEW_COUNT = "view_count";
        public static final String FIELD_LIKE_COUNT = "like_count";

        public static final long ADD_ONE = 1;
        public static final long SUB_ONE = -1;
        // ========================================================

        public static String KEY_ARTICLE_PREFIX(String id) {
            return ARTICLE_PREFIX + id;
        }

        /**
         * 获取 博客id
         *
         * @return {@link Mono<Long>}
         */
        public static Mono<Long> incrBlogId() {
            return reactive().incr(KEY_BLOG_COUNT);
        }
    }

    /**
     * 博客 实体类
     *
     * @author pdd20
     */
    @Data
    @NoArgsConstructor
    public static class Blog {
        private String id;
        private String title;
        private String content;
        private String author;
        private Date time;

        private long contentLength;
        private long likeCount;
        private long viewCount;

        public Blog(String id) {
            this.id = id;
        }

        public Blog(String id, String title, String content, String author, Date time) {
            this.id = id;
            this.title = title;
            this.content = content;
            this.author = author;
            this.time = time;
        }
    }
~~~





## 测试代码

~~~java
 public static void main(String[] args) {
        对博客网站案例代码进行重构_09 test = new 对博客网站案例代码进行重构_09();
        // 1.发布博客
        String id = UUID.randomUUID().toString();
        test.publishBlog(id, "我喜欢学习redis", "学习redis和lettuce很快乐", "like", new Date()).subscribe(res -> {
            for (int i = 0; i < 10; i++) {
                test.incrViewBlogCount(id).subscribe();
                test.likeBlog(id).subscribe();
            }

            // 2.查看博客
            test.getBlog(id).subscribe(list->{
                Blog blog = BeanUtil.mapToBean(list.stream().collect(Collectors.toMap(KeyValue::getKey, KeyValue::getValue)), Blog.class, false, null);
                System.out.println(blog);
            });

        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
~~~





![image-20210507203433808](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210507203436.png)





# 10.基于令牌的用户登录会话机制

用户登录通过后，会返回浏览器或者客户端一块令牌，同时在redis初始化好一个session会话，后续客户端就会在指定时间范围内发送请求的时候带上令牌，每次令牌和服务端的session校验通过就可以执行请求。

过一段时间后，redis里面的session会话可能过期，这就会导致又要重新登录，虽然带上了令牌，但是一检查发现这个令牌对应在redis中的session已经过期了

```java
public class 基于令牌的用户登录会话机制_10 {
    public static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
    private final static Logger log = getLogger(基于令牌的用户登录会话机制_10.class);
    private static final String KEY_SESSIONS = "sessions:token";
    private static final String KEY_SESSIONS_EXPIRE_TIME = "sessions:expire_time";
    /** session 过期时间 30min */
    public static final long expire = 60 * 30 * 1000;

    public static String FIELD_SESSION_TOKEN(String token) {
        return "session:" + token;
    }

    /**
     * 判断session是否有效
     *
     * @param token 令牌
     * @return boolean
     */
    public boolean isSessionValid(String token) {
        Preconditions.checkNotNull(token);

        String session;
        String expireTimeStr = null;
        Date expireTimeDate;
        try {
            // 判断token对应的session是否存在
            session = reactive().hget(KEY_SESSIONS, FIELD_SESSION_TOKEN(token)).block();
            if (StrUtil.isBlank(session)) return false;

            // 判断token对应的过期时间是否存在
            expireTimeStr = reactive().hget(KEY_SESSIONS_EXPIRE_TIME, FIELD_SESSION_TOKEN(token)).block();
            if (StrUtil.isBlank(expireTimeStr)) return false;

            // 判断是否过期
            expireTimeDate = sdf.parse(expireTimeStr);
            if (new Date().after(expireTimeDate)) return false;
        } catch (ParseException e) {
            log.error("[isSessionValid][ sdf.parse(expireTimeStr)类型转换错误( token:{},expireTimeStr: {} )]", token, expireTimeStr);
        }
        return true;
    }

    /**
     * 初始化会话
     *
     * @param userId 用户id
     * @param token  令牌
     */
    public void initSession(String userId, String token) {
        long expireTimeLong = new Date().getTime() + expire;
        reactive().hset(KEY_SESSIONS, FIELD_SESSION_TOKEN(token), userId).subscribe();
        reactive().hset(KEY_SESSIONS_EXPIRE_TIME, FIELD_SESSION_TOKEN(token), sdf.format(expireTimeLong)).subscribe();
    }
}
```





## test

```java
public static void main(String[] args) {
    基于令牌的用户登录会话机制_10 test = new 基于令牌的用户登录会话机制_10();
    String token = "33333";
    String userId = "123";
    test.initSession(userId, token);

    System.out.println(test.isSessionValid(token));
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }

    System.out.println(test.isSessionValid(token));
}
```

![image-20210507212722546](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210507212731.png)

![image-20210507212726646](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210507212729.png)





# 11.秒杀活动下的公平队列抢购机制

对所有涌入系统的秒杀抢购请求，都放入redis的一个list数据结构里面，进行公平队列排队，然后入队之后等待秒杀结果。专门搞一个消费者从list里面按顺序获取抢购请求，按顺序进行库存扣减，扣减成功就是抢购成功。

公平队列，基于redis的==list==数据结构，搞一个队列，抢购请求都进队，==先入先出==，先来的人先抢购。

~~~
队列：先入先出
lpush  放到最尾
rpop   取出头

栈：后入先出
lpush
lpop
~~~



```java
public class 秒杀活动下的公平队列抢购机制_11 {

    /**
     * 产生秒杀请求
     *
     * @param secKillRequest 秒杀请求
     * @return {@link Mono<Long>}
     */
    public Mono<Long> produceSecLKillRequest(String secKillRequest) {
        return reactive().lpush("sec_kill_request", secKillRequest);
    }

    /**
     * 获取秒杀请求
     *
     * @return {@link Mono<String>}
     */
    public Mono<String> consumeSecKillRequest() {
        return reactive().rpop("sec_kill_request");
    }
}
```





## test

  public static void main(String[] args) {
        秒杀活动下的公平队列抢购机制_11 test = new 秒杀活动下的公平队列抢购机制_11();
        for (int i = 0; i < 10; i++) {
            test.produceSecLKillRequest(String.format("第%s个秒杀请求", i + 1)).block();
        }

```java
    for (int i = 0; i < 10; i++) {
        test.consumeSecKillRequest().subscribe(req -> {
            if (StrUtil.isBlank(req)) {
                throw new RuntimeException();
            }
            System.out.println("req = " + req);
        });
    }
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```



![image-20210509091322110](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509091358.png)





# 12.实现OA系统中的待办事项列表管理

~~~
lindex,lset,linsert,ltrim,lrem
~~~

OA系统，自动化办公系统，就是公司日常运行的办公的日常事务都在OA系统里面来做，请假，审批，开会，项目，任务，==待办事项列表==。

新增

插入

查询

完成

修改待办事项

查询已经完成的待办事项





~~~java
public class 实现OA系统中的待办事项列表管理_12 {

    public static String KEY_TODO_EVENT(String userId) {
        return "todoEvent:" + userId;
    }

    public static String KEY_COMPLETE_TODO_EVENT(String userId) {
        return "competeTodoEvent:" + userId;
    }

    /**
     * 添加todo事件
     *
     * @param userId    用户id
     * @param todoEvent todo事件
     * @return {@link Mono<Long>}
     */
    public Mono<Long> addTodoEvent(String userId, String todoEvent) {
        return reactive().rpush(KEY_TODO_EVENT(userId), todoEvent);
    }

    /**
     * todo事件 列表
     *
     * @param userId     用户id
     * @param pageSize   页面大小
     * @param pageNumber 页码
     * @return {@link Flux<List<String>>}
     */
    public Flux<List<String>> listTodoEvent(String userId, int pageNumber, int pageSize) {
        int start = PageUtil.getStart(pageNumber, pageSize);
        return reactive().lrange(KEY_TODO_EVENT(userId), start, start + pageSize).buffer();
    }

    /**
     * 插入todo事件
     *
     * @param userId    用户id
     * @param todoEvent todo事件
     * @param index     插入索引
     */
    public void insertTodoEvent(String userId, String todoEvent, int index) {
        String key = KEY_TODO_EVENT(userId);

        String pivot = reactive().lindex(key, index).block();
        if (StrUtil.isBlank(pivot)) return;

        reactive().linsert(key, true, pivot, todoEvent).subscribe();

    }

    /**
     * 完成任务的事件
     *
     * @param userId 用户id
     * @param index  指数
     */
    public void completeTodoEvent(String userId, int index) {
        String todoEvent = reactive().lindex(KEY_TODO_EVENT(userId), index).block();
        if (StrUtil.isBlank(todoEvent)) return;

        reactive().lrem(KEY_TODO_EVENT(userId), 1, todoEvent).subscribe(count -> {
            System.out.println("block = " + count);
            if (count > 0) {
                System.out.println("完成" + todoEvent);

                reactive().rpush(KEY_COMPLETE_TODO_EVENT(userId), todoEvent).subscribe();
            } ;
        });
    }

    /**
     * 查看完成的todo事件
     *
     * @param userId     用户id
     * @param pageNumber 页码
     * @param pageSize   页面大小
     * @return {@link Flux<List<String>>}
     */
    public Flux<List<String>> viewCompleteTodoEvent(String userId, int pageNumber, int pageSize) {
        int start = PageUtil.getStart(pageNumber, pageSize);
        return reactive().lrange(KEY_COMPLETE_TODO_EVENT(userId), start, start + pageSize).buffer();
    }
}
~~~





~~~java
public static void main(String[] args) {
    实现OA系统中的待办事项列表管理_12 test = new 实现OA系统中的待办事项列表管理_12();
    String userId = UUID.randomUUID().toString();
    for (int i = 0; i < 20; i++) {
        test.addTodoEvent(userId, String.format("第%s个待办事项", i + 1)).subscribe();
    }

    test.listTodoEvent(userId, 0, 20).subscribe(s -> {
        System.out.println("第一次");
        System.out.println(s);
    });

    int index = 3;
    test.completeTodoEvent(userId, index);

    test.listTodoEvent(userId, 0, 20).subscribe(s -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("第二次");
        System.out.println(s);
    });


    test.insertTodoEvent(userId, "插入到第3个位置的后面", index);

    test.listTodoEvent(userId, 0, 20).subscribe(s -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("第三次");
        System.out.println(s);
    });


    test.viewCompleteTodoEvent(userId, 0, 20).subscribe(s -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("查看完成的");
        System.out.println(s);
    });


    try {
        TimeUnit.SECONDS.sleep(4);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
~~~

![image-20210509105704369](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105721.png)

![image-20210509105708767](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105723.png)

![image-20210509105713219](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105725.png)

![image-20210509105718243](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105727.png)





# 13.实现网站用户注册时的邮件验证机制

一般来说在注册后台里面，是否在注册的时候里面直接就发送一封邮件呢？不是的，通常来说，在注册成功后，一般会把注册成功的邮件任务发送到一个队列里面，然后直接返回成功给你。

~~~
brpop 可以做成一个阻塞队列的效果（time out）
~~~



~~~java
public class 实现网站用户注册时的邮件验证机制_13 {


    public static String KEY_SEND_MALL_TASK_QUEUE = "send_mall_task_queue";

    public static void main(String[] args) {


        实现网站用户注册时的邮件验证机制_13 test = new 实现网站用户注册时的邮件验证机制_13();

        for (int i = 0; i < 10; i++) {
            String userId = UUID.randomUUID().toString();
            String emailAddress = "98065920@qq.com";
            MallTask mallTask = new MallTask(userId, emailAddress);
            test.emailTaskEnQueue(mallTask).subscribe(s -> {
                System.out.println("s = " + s);
            });
        }

        test.emailTaskDeQueue().subscribe(s -> {
            System.out.println("s.getKey() = " + s.getKey());
            System.out.println("s.getValue() = " + s.getValue());
        });


        try {
            TimeUnit.SECONDS.sleep(7);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 电子邮件任务 入队
     *
     * @param mallTask 购物中心的任务
     * @return {@link Mono<Long>}
     */
    public Mono<Long> emailTaskEnQueue(MallTask mallTask) {
        return reactive().lpush(KEY_SEND_MALL_TASK_QUEUE, JSONUtil.toJsonStr(mallTask));
    }

    public Mono<KeyValue<String, String>> emailTaskDeQueue() {
        return reactive().brpop(5000, KEY_SEND_MALL_TASK_QUEUE);
    }


    @AllArgsConstructor
    @Data
    static class MallTask {
        private String userId;
        private String emailAddress;
    }
~~~





# 14.网站每日UV数据指标去重统计

使用set存放，每次用户登录的时候就添加一次

~~~java
public class 网站每日UV数据指标去重统计_14 {

    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(DatePattern.CHINESE_DATE_PATTERN);
    public static final SimpleDateFormat DATE_TIME_FORMAT = new SimpleDateFormat(DatePattern.CHINESE_DATE_TIME_PATTERN);

    private static final String KEY_USER_ACCESS_COUNT_SET = "USER_ACCESS_COUNT_SET:" + DATE_FORMAT.format(new Date());

    public Mono<Long> addUserAccess(String... userIds) {
        return reactive().sadd(KEY_USER_ACCESS_COUNT_SET, userIds);
    }

    public Long viewUserAccessCount() {
        return reactive().scard(KEY_USER_ACCESS_COUNT_SET).block();
    }
}
~~~





## test

public static void main(String[] args) {
        网站每日UV数据指标去重统计_14 test = new 网站每日UV数据指标去重统计_14();
        for (int i = 1; i <= 100; i++) {
            for (int j = 0; j < 10; j++) {
                test.addUserAccess(String.valueOf(i)).block();
            }
        }

```java
    System.out.println("uv:" + test.viewUserAccessCount());

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```







# 15.博客网站的文章标签管理

在一个博客网站发表一篇文章的时候，都可以自定义给这篇文章打上一些标签，==Java==，==大数据==，==软件架构==等。对于一篇标签来说，标签是不能重复的。标签就直接可以用set来保存。

~~~
smembers key   # 获取标签
sadd key value... # 添加标签
sismember key value # 查看是否有这个标签
srem key value... # 移除标签
~~~





![image-20210509182317711](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509182332.png)



![image-20210509182326780](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509182328.png)





# 16.朋友圈点赞功能的实现

假设说，你发了一条朋友圈，此时你的好友可能会点赞，取消点赞。好友也可以查看是否对这个朋友圈点赞。你也可以查看这条朋友圈有多少人点赞，哪些人点赞

~~~
sadd # 添加一个好友点赞
srem # 取消点赞
sismember # 你是否对某朋友圈点赞
smembers # 有哪些人点赞
~~~





~~~java
public class 朋友圈点赞功能的实现_16 {

    /**
     * 点赞
     *
     * @param user     用户
     * @param momentId 时刻id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> like(String user, String momentId) {
        return reactive().sadd("moment_like_user_set:" + momentId, user);
    }

    /**
     * 取消点赞
     *
     * @param user     用户
     * @param momentId 时刻id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> disLike(String user, String momentId) {
        return reactive().srem("moment_like_user_set:" + momentId, user);
    }

    /**
     * 是否点赞
     *
     * @param user     用户
     * @param momentId 时刻id
     * @return {@link Mono<Boolean>}
     */
    public Mono<Boolean> hasLike(String user, String momentId) {
        return reactive().sismember(user, momentId);
    }

    /**
     * 点赞的用户
     *
     * @param momentId 时刻id
     * @return {@link Flux<String>}
     */
    public Flux<String> likeUsers(String momentId) {
        return reactive().smembers("moment_like_user_set:" + momentId);
    }

    /**
     * 点赞的数量
     *
     * @param momentId 时刻id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> likeCount(String momentId) {
        return reactive().scard("moment_like_user_set:" + momentId);
    }
}

~~~





## test

~~~java
public static void main(String[] args) {
    朋友圈点赞功能的实现_16 test = new 朋友圈点赞功能的实现_16();
    List<String> likeUsers;
    // 我的朋友
    String u1 = "小明";
    String u2 = "小可";
    String u3 = "小雷";
    String u4 = "小新";

    // 我发了一条朋友圈
    String momentId = "1";

    // u1 u2 u3 u4 对我的朋友圈点赞了
    test.like(u1,momentId).subscribe();
    test.like(u2,momentId).subscribe();
    test.like(u3,momentId).subscribe();
    test.like(u4, momentId).subscribe();

    likeUsers = test.likeUsers(momentId).collect(Collectors.toList()).block();
    System.out.println("第一次："+likeUsers);

    // u3取消点赞
    test.disLike(u3, momentId).subscribe();
    likeUsers = test.likeUsers(momentId).collect(Collectors.toList()).block();
    System.out.println("第二次："+likeUsers);
    // 查看是否点赞了
    test.hasLike(u3, momentId).subscribe(s->{
        System.out.println(s);
    });


    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
~~~







# 17.实现一个网站投票统计程序

用户对投票项进行投票，检查用户是否投票过，查看投票项共有多少人投过。

~~~java
public class 实现一个网站投票统计程序_17 {

    private String KEY_VOTE_TOPIC(String topic) {
        return "vote_topic:" + topic;
    }

    public Mono<Long> vote(String user, String topic) {
        return reactive().sadd(KEY_VOTE_TOPIC(topic), user);
    }

    public Mono<Boolean> hasVote(String user, String topic) {
        return reactive().sismember(KEY_VOTE_TOPIC(topic), user);
    }

    public Mono<Long> voteCount(String topic) {
        return reactive().scard(KEY_VOTE_TOPIC(topic));
    }

    public static void main(String[] args) {
        List<String> topics = Arrays.asList("like 很帅", "like 不帅");

        实现一个网站投票统计程序_17 test = new 实现一个网站投票统计程序_17();
        for (int i = 0; i < 100000; i++) {
            int chose = RandomUtil.randomInt(0, 2);

            test.vote(String.valueOf(i), topics.get(chose)).subscribe();

        }

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }

        test.voteCount(topics.get(0)).subscribe(s -> {
            System.out.println(topics.get(0) + " : " + s);
        });

        test.voteCount(topics.get(1)).subscribe(s -> {
            System.out.println(topics.get(1) + " : " + s);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 18.实现类似微博的社交关系

你可以关注一个博主，取消关注，你可以查看你关注的，也可以查看关注你的



~~~java
public class 实现类似微博的社交关系_18 {

    /**
     * 订阅
     *
     * @param beSubscribedTo 被订阅
     * @param user           用户
     */
    public void subscribe(String beSubscribedTo, String user) {
        reactive().sadd("user:" + user + ":stars", beSubscribedTo).subscribe();
        reactive().sadd("user:" + beSubscribedTo + ":fans", user).subscribe();
    }

    /**
     * 取消订阅
     *
     * @param beSubscribedTo 被订阅
     * @param user           用户
     */
    public void unSubscribe(String beSubscribedTo, String user) {
        reactive().srem("user::" + user + "::stars", beSubscribedTo).subscribe();
        reactive().srem("user::" + beSubscribedTo + "::fans", user).subscribe();
    }

    /**
     * 查看关注的用户
     *
     * @param user 用户
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> stars(String user) {
        return reactive().smembers("user:" + user + ":stars").collect(Collectors.toSet());
    }

    /**
     * 查看关注用户的数
     *
     * @param user 用户
     * @return {@link Mono<Long>}
     */
    public Mono<Long> starsCount(String user) {
        return reactive().scard("user:" + user + ":stars");
    }


    /**
     * 查看粉丝
     *
     * @param user 用户
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> fans(String user) {
        return reactive().smembers("user:" + user + ":fans").collect(Collectors.toSet());
    }

    /**
     * 查看粉丝数
     *
     * @param user 用户
     * @return {@link Mono<Long>}
     */
    public Mono<Long> fansCount(String user) {
        return reactive().scard("user:" + user + ":fans");
    }
}
~~~





## test

~~~java
 public static void main(String[] args) {
        String u1 = "小q";
        String u2 = "小w";
        String u3 = "小z";
        String u4 = "我";

        实现类似微博的社交关系_18 test = new 实现类似微博的社交关系_18();

        // 2、3、4 都关注 1
        test.subscribe(u1, u2);
        test.subscribe(u1, u3);
        test.subscribe(u1, u4);

        // 2、3 关注我
        test.subscribe(u4, u3);
        test.subscribe(u4, u2);
        test.subscribe(u4, u1);

        test.stars(u4).subscribe(s -> {
            System.out.println(u4 + "关注了：" + s);
        });

        test.fans(u4).subscribe(s -> {
            System.out.println(u4 + "的粉丝有：" + s);
        });

        test.fans(u1).subscribe(s -> {
            System.out.println(u1 + "的粉丝有：" + s);
        });


        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
~~~





# 19.微博的共同关注与推荐关注的功能实现

获取我和另一个人的共同好友

获取推荐给我的可以关注的人，我关注的人的关注的人



~~~java
	/**
     * 共同的关注
     *
     * @param u1 me
     * @param u2 myFriend
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> sameStars(String u1, String u2) {
        return reactive().sinter("user:" + u1 + ":stars", "user:" + u2 + ":stars").collect(Collectors.toSet());
    }

    /**
     * 推荐关注（u2向u1推荐->u2中u1没有关注的）
     *
     * @param u1 me
     * @param u2 myFriend
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> recommendStars(String u1, String u2) {
        return reactive().sdiff("user:" + u2 + ":stars", "user:" + u1 + ":stars").collect(Collectors.toSet());
    }
~~~

