此笔记对应代码在

~~~
代码/actualCombat/redis-actualCombat/src/main/java/cn/like/redis/testCase
~~~





# 0.redis 连接

~~~java
package cn.like.redis.testCase;

import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisURI;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.reactive.RedisReactiveCommands;

import java.time.Duration;
import java.time.temporal.ChronoUnit;

/**分布式锁
 * redis 连接程序
 *
 * @author like
 * @date 2021-05-05 13:46
 */
public class Redis {

    private Redis() {
    }

    public static RedisReactiveCommands<String, String> cmd() {
        RedisURI uri = RedisURI.builder()
                .withHost("localhost")
                .withPort(6379)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        RedisClient redisClient = RedisClient.create(uri);
        StatefulRedisConnection<String, String> connect = redisClient.connect();

        RedisReactiveCommands<String, String> cmd = connect.reactive();

        while (true) {
            if (cmd.isOpen()) {
                return cmd;
            }
        }
    }
}
~~~





# 1.案例实战：最普通的基于Redis实现的缓存机制

~~~
set
~~~



比如说，一个很复杂的查询，就可以用redis作为缓存

~~~java
public class 普通的基于redis的缓存_01 {
    private static final Logger log = LoggerFactory.getLogger(普通的基于redis的缓存_01.class);

    public static void main(String[] args) {
        redisCmd().set("hello", "world").block();

        redisCmd().get("hello").subscribe(v -> {
            log.info("[main] [hello]: {}", v);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 2.案例实战：实现一个最简单的分布式锁

~~~
set nx ex
~~~



~~~java
public class 实现一个最简单的分布式锁_02 {

    private final static Logger log = LoggerFactory.getLogger(实现一个最简单的分布式锁_02.class);

    public static void main(String[] args) {
        int count = 0;
        String lock = "lock_test";

        // 第一次加锁
        count = lock(count, lock);

        // 第二次加锁
        count = lock(count, lock);
        // 删除lock
        cmd().del(lock).block();

        // 第三次加锁
        lock(count, lock);

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static int lock(int count, String lock) {
        String res = cmd().set(lock, String.valueOf(++count), SetArgs.Builder.ex(100).nx())
                .block();

        System.out.println("[main] [第  " + count + " 次 加锁 ]" + res);
        return count;
    }
}
~~~





# 3.案例实战：实现博客网站的文章发布与查看

~~~bash
mset
mget
msetnx

m -> multi ，多个

相当于batch批量的设置和查询。
~~~



~~~java
public class 实现博客网站的文章发布与查看_03 {
    private final static Logger log = getLogger(实现博客网站的文章发布与查看_03.class);

    public static void main(String[] args) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");

        // 存
        HashMap<String, String> map = new HashMap<>(16);
        map.put("article:1:title", "学习使用redis");
        map.put("article:1:content", "实现博客网站的文章发布与查看");
        map.put("article:1:author", "like");
        map.put("article:1:time", sdf.format(new Date()));

        String res = cmd().mset(map).block();

        System.out.println(res);

        // 取
        Flux<KeyValue<String, String>> flux = cmd().mget("article:1:title");
        KeyValue<String, String> s = flux.blockLast();
        System.out.println(s);

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}



# 4.实现博客字数统计与文章预览

​~~~bash
strlen				# 获取指定key的长度
grange 				# 获取 指定长度的数据  start offset
~~~



~~~java
public class 实现博客字数统计与文章预览_04 {

    public static void main(String[] args) {
        cmd().mget("article:1:title", "article:1:content", "article:1:author", "article:1:time")
                .subscribe(kv -> {
                    // 一条一条的消费
                    kv.map(s -> {
                        System.out.println(s);
                        return true;
                    });
                });

        // strlen
        cmd().strlen("article:1:content").subscribe(res -> {
            System.out.println("博客长度:" + res);
        });
        // getrange
        cmd().getrange("article:1:content", 0, 11).subscribe(res -> {
            System.out.println("博客预览:" + res);
        });
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 5.实现用户操作日志审计功能

~~~bash
append
~~~



把用户在系统里面的操作记录下来，每一条操作都记录成一条日志。后续可以通过一个列表来进行查询，分页查询。如果说要记录redis来存储这种操作审计日志，应该如何来做？

也可以在redis中存一个key，每天都有一个key，每天的这个key里面就把当天所有的操作日志都串联起来，查询的时候，都是按天来查询你的操作审计日志。

key -> value,value 字符串拼接

append可以不停把日志追加到指定的key



~~~java
public class 实现用户操作日志审计功能_05 {

    public static void main(String[] args) {
        String now = DateUtil.now();
        String key = "operation_log_"+ now;
        cmd().setnx(key, "").block();

        for (int i = 1; i < 10; i++) {
            cmd().append(key, "今天的第" + (i) + "条操作日志\n").block();
        }

        cmd().get(key).subscribe(System.out::println);

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~



# 6.实现一个简单的唯一ID生成器

一般都是通过数据库的自增主键来实现的，在一些场景下，分库分表，同一个表的数据都会分散在多个库的多个表里面，这个时候就不是光靠数据库来生成自增长的主键，就需要当前的功能了

snowflake算法，还有一些开源大厂的唯一id生成组件。

~~~
incr 
~~~



# 7.实现博客点赞次数计数器

~~~
incr
~~~



```java
public class 实现博客点赞次数计数器_07 {

    public static void main(String[] args) {
        cmd().incr("article:1:goodCount");
    }
}
```





# 8.实现社交网站的网址点击追踪机制（短链接）

~~~
hset
hget
hincrby
~~~



社交网站一般会把你发表的一些微博里面的**长链接**转换为**短链接**，这样可以利用短链接进行点击数量追踪，然后再让你进入短链接对应的长连接地址里面，

http://qwe.cn/ASDZsdg -> http://redos.com/index.html

利用redis的incr自增长，然后10进制转36进制，然后hset存放在hash数据结构里面，在提供一个映射转换的hget获取方法

~~~java
public class 实现社交网站的网址点击追踪机制_08 {

    public static final String X36 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    public static final String[] X36_ARRAY = X36.split("");

    /** 根据当前seed生成短链接 越大越看不懂 */
    private static final String KEY_SHORT_URL_SEED = "SHORT_URL_SEED";
    /**
     * 短连接访问次数
     * SHORT_URL_ACCESS_COUNT:{
     *  https://like.com/97G78 : 156
     *  https://like.com/6gQDf : 334
     * }
     */
    private static final String KEY_SHORT_URL_ACCESS_COUNT = "SHORT_URL_ACCESS_COUNT";
    /**
     * 长短 url映射
     * URL_MAPPING:{
     *  https://like.com/97G78 :https://apppukyptrl1086.pc.xia123oe-tech.com
     * }
     */
    private static final String KEY_URL_MAPPING = "URL_MAPPING";
    /** 网络前缀 */
    private static final String WEB_PREFIX = "https://like.com/";

    /**
     * 得到短url
     *
     * @param url url
     * @return {@link String}
     */
    public String getShortUrl(String url) {
        Long shortUrlSeed = cmd().incr(KEY_SHORT_URL_SEED).block();

        StringBuilder sb = new StringBuilder();

        if (shortUrlSeed == null || shortUrlSeed == 0) {
            shortUrlSeed = 0L;
            sb.append("0");
        }

        // 转换为36进制
        while (shortUrlSeed > 0) {
            sb.append(X36_ARRAY[(int) (shortUrlSeed % 36L)]);
            shortUrlSeed = shortUrlSeed / 36;
        }

        sb.reverse();
        String shortUrl = sb.insert(0, WEB_PREFIX).toString();

        cmd().hset(KEY_SHORT_URL_ACCESS_COUNT, shortUrl, "0").subscribe();
        cmd().hset(KEY_URL_MAPPING, shortUrl, url).subscribe();

        return shortUrl;
    }

    /**
     * 增加 shortUrl 的访问次数
     *
     * @param shortUrl 短网址
     */
    public void incrementShortURLAccessCount(String shortUrl) {
        cmd().hincrby(KEY_SHORT_URL_ACCESS_COUNT, shortUrl, 1).subscribe();
    }

    /**
     * 增加 shortUrl 的访问次数
     *
     * @param shortUrl 短网址
     */
    public Long getShortURLAccessCount(String shortUrl) {
        return Long.valueOf(cmd().hget(KEY_SHORT_URL_ACCESS_COUNT, shortUrl).block());
    }
}
~~~





## test

~~~java
public static void main(String[] args) {
    实现社交网站的网址点击追踪机制_08 test = new 实现社交网站的网址点击追踪机制_08();
    String shortUrl = test.getShortUrl("https://apppukyptrl1086.pc.xia123oe-tech.com");
    System.out.println("短链接为:" + shortUrl);

    for (int i = 0; i < 133; i++) {
        test.incrementShortURLAccessCount(shortUrl);
    }
    System.out.println("访问次数" + test.getShortURLAccessCount(shortUrl));
}
~~~



![image-20210505183705100](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183816.png)

![image-20210505183711006](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183823.png)

![image-20210505183716066](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183818.png)





# 9.案例实战：对博客网站案例代码进行重构

博客网站，发布一篇文章，修改一篇文章，查看一篇文章，有人查看了一下这篇文章，就可以维护一下他的浏览次数，对于这个浏览次数就都可以统一放在一个hash数据结构里面。

==key就是文章编号，value就是文章浏览次数==

