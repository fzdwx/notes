此笔记对应代码在

~~~
代码/actualCombat/redis-actualCombat/src/main/java/cn/like/redis/testCase
~~~





# 0.redis 连接

~~~java
package cn.like.redis.testCase;

import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisURI;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.reactive.RedisReactiveCommands;

import java.time.Duration;
import java.time.temporal.ChronoUnit;

/**分布式锁
 * redis 连接程序
 *
 * @author like
 * @date 2021-05-05 13:46
 */
public class Redis {

    private Redis() {
    }

    public static RedisReactiveCommands<String, String> cmd() {
        RedisURI uri = RedisURI.builder()
                .withHost("localhost")
                .withPort(6379)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        RedisClient redisClient = RedisClient.create(uri);
        StatefulRedisConnection<String, String> connect = redisClient.connect();

        RedisReactiveCommands<String, String> cmd = connect.reactive();

        while (true) {
            if (cmd.isOpen()) {
                return cmd;
            }
        }
    }
}
~~~





# 1.案例实战：最普通的基于Redis实现的缓存机制

~~~
set
~~~



比如说，一个很复杂的查询，就可以用redis作为缓存

~~~java
public class 普通的基于redis的缓存_01 {
    private static final Logger log = LoggerFactory.getLogger(普通的基于redis的缓存_01.class);

    public static void main(String[] args) {
        redisCmd().set("hello", "world").block();

        redisCmd().get("hello").subscribe(v -> {
            log.info("[main] [hello]: {}", v);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 2.案例实战：实现一个最简单的分布式锁

~~~
set nx ex
~~~



~~~java
public class 实现一个最简单的分布式锁_02 {

    private final static Logger log = LoggerFactory.getLogger(实现一个最简单的分布式锁_02.class);

    public static void main(String[] args) {
        int count = 0;
        String lock = "lock_test";

        // 第一次加锁
        count = lock(count, lock);

        // 第二次加锁
        count = lock(count, lock);
        // 删除lock
        cmd().del(lock).block();

        // 第三次加锁
        lock(count, lock);

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static int lock(int count, String lock) {
        String res = cmd().set(lock, String.valueOf(++count), SetArgs.Builder.ex(100).nx())
                .block();

        System.out.println("[main] [第  " + count + " 次 加锁 ]" + res);
        return count;
    }
}
~~~





# 3.案例实战：实现博客网站的文章发布与查看

~~~bash
mset
mget
msetnx

m -> multi ，多个

相当于batch批量的设置和查询。
~~~



~~~java
public class 实现博客网站的文章发布与查看_03 {
    private final static Logger log = getLogger(实现博客网站的文章发布与查看_03.class);

    public static void main(String[] args) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");

        // 存
        HashMap<String, String> map = new HashMap<>(16);
        map.put("article:1:title", "学习使用redis");
        map.put("article:1:content", "实现博客网站的文章发布与查看");
        map.put("article:1:author", "like");
        map.put("article:1:time", sdf.format(new Date()));

        String res = cmd().mset(map).block();

        System.out.println(res);

        // 取
        Flux<KeyValue<String, String>> flux = cmd().mget("article:1:title");
        KeyValue<String, String> s = flux.blockLast();
        System.out.println(s);

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}



# 4.实现博客字数统计与文章预览

​~~~bash
strlen				# 获取指定key的长度
grange 				# 获取 指定长度的数据  start offset
~~~



~~~java
public class 实现博客字数统计与文章预览_04 {

    public static void main(String[] args) {
        cmd().mget("article:1:title", "article:1:content", "article:1:author", "article:1:time")
                .subscribe(kv -> {
                    // 一条一条的消费
                    kv.map(s -> {
                        System.out.println(s);
                        return true;
                    });
                });

        // strlen
        cmd().strlen("article:1:content").subscribe(res -> {
            System.out.println("博客长度:" + res);
        });
        // getrange
        cmd().getrange("article:1:content", 0, 11).subscribe(res -> {
            System.out.println("博客预览:" + res);
        });
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 5.实现用户操作日志审计功能

~~~bash
append
~~~



把用户在系统里面的操作记录下来，每一条操作都记录成一条日志。后续可以通过一个列表来进行查询，分页查询。如果说要记录redis来存储这种操作审计日志，应该如何来做？

也可以在redis中存一个key，每天都有一个key，每天的这个key里面就把当天所有的操作日志都串联起来，查询的时候，都是按天来查询你的操作审计日志。

key -> value,value 字符串拼接

append可以不停把日志追加到指定的key



~~~java
public class 实现用户操作日志审计功能_05 {

    public static void main(String[] args) {
        String now = DateUtil.now();
        String key = "operation_log_"+ now;
        cmd().setnx(key, "").block();

        for (int i = 1; i < 10; i++) {
            cmd().append(key, "今天的第" + (i) + "条操作日志\n").block();
        }

        cmd().get(key).subscribe(System.out::println);

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~



# 6.实现一个简单的唯一ID生成器

一般都是通过数据库的自增主键来实现的，在一些场景下，分库分表，同一个表的数据都会分散在多个库的多个表里面，这个时候就不是光靠数据库来生成自增长的主键，就需要当前的功能了

snowflake算法，还有一些开源大厂的唯一id生成组件。

~~~
incr 
~~~



# 7.实现博客点赞次数计数器

~~~
incr
~~~



```java
public class 实现博客点赞次数计数器_07 {

    public static void main(String[] args) {
        cmd().incr("article:1:goodCount");
    }
}
```





# 8.实现社交网站的网址点击追踪机制（短链接）

~~~
hset
hget
hincrby
~~~



社交网站一般会把你发表的一些微博里面的**长链接**转换为**短链接**，这样可以利用短链接进行点击数量追踪，然后再让你进入短链接对应的长连接地址里面，

http://qwe.cn/ASDZsdg -> http://redos.com/index.html

利用redis的incr自增长，然后10进制转36进制，然后hset存放在hash数据结构里面，在提供一个映射转换的hget获取方法

~~~java
public class 实现社交网站的网址点击追踪机制_08 {

    public static final String X36 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    public static final String[] X36_ARRAY = X36.split("");

    /** 根据当前seed生成短链接 越大越看不懂 */
    private static final String KEY_SHORT_URL_SEED = "SHORT_URL_SEED";
    /**
     * 短连接访问次数
     * SHORT_URL_ACCESS_COUNT:{
     *  https://like.com/97G78 : 156
     *  https://like.com/6gQDf : 334
     * }
     */
    private static final String KEY_SHORT_URL_ACCESS_COUNT = "SHORT_URL_ACCESS_COUNT";
    /**
     * 长短 url映射
     * URL_MAPPING:{
     *  https://like.com/97G78 :https://apppukyptrl1086.pc.xia123oe-tech.com
     * }
     */
    private static final String KEY_URL_MAPPING = "URL_MAPPING";
    /** 网络前缀 */
    private static final String WEB_PREFIX = "https://like.com/";

    /**
     * 得到短url
     *
     * @param url url
     * @return {@link String}
     */
    public String getShortUrl(String url) {
        Long shortUrlSeed = cmd().incr(KEY_SHORT_URL_SEED).block();

        StringBuilder sb = new StringBuilder();

        if (shortUrlSeed == null || shortUrlSeed == 0) {
            shortUrlSeed = 0L;
            sb.append("0");
        }

        // 转换为36进制
        while (shortUrlSeed > 0) {
            sb.append(X36_ARRAY[(int) (shortUrlSeed % 36L)]);
            shortUrlSeed = shortUrlSeed / 36;
        }

        sb.reverse();
        String shortUrl = sb.insert(0, WEB_PREFIX).toString();

        cmd().hset(KEY_SHORT_URL_ACCESS_COUNT, shortUrl, "0").subscribe();
        cmd().hset(KEY_URL_MAPPING, shortUrl, url).subscribe();

        return shortUrl;
    }

    /**
     * 增加 shortUrl 的访问次数
     *
     * @param shortUrl 短网址
     */
    public void incrementShortURLAccessCount(String shortUrl) {
        cmd().hincrby(KEY_SHORT_URL_ACCESS_COUNT, shortUrl, 1).subscribe();
    }

    /**
     * 增加 shortUrl 的访问次数
     *
     * @param shortUrl 短网址
     */
    public Long getShortURLAccessCount(String shortUrl) {
        return Long.valueOf(cmd().hget(KEY_SHORT_URL_ACCESS_COUNT, shortUrl).block());
    }
}
~~~





## test

~~~java
public static void main(String[] args) {
    实现社交网站的网址点击追踪机制_08 test = new 实现社交网站的网址点击追踪机制_08();
    String shortUrl = test.getShortUrl("https://apppukyptrl1086.pc.xia123oe-tech.com");
    System.out.println("短链接为:" + shortUrl);

    for (int i = 0; i < 133; i++) {
        test.incrementShortURLAccessCount(shortUrl);
    }
    System.out.println("访问次数" + test.getShortURLAccessCount(shortUrl));
}
~~~



![image-20210505183705100](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183816.png)

![image-20210505183711006](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183823.png)

![image-20210505183716066](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210505183818.png)





# 9.案例实战：对博客网站案例代码进行重构

博客网站，发布一篇文章，修改一篇文章，查看一篇文章，有人查看了一下这篇文章，就可以维护一下他的浏览次数，对于这个浏览次数就都可以统一放在一个hash数据结构里面。

==key就是文章编号,field就是博客的字段，value就是字段对应的==

~~~java
public class 对博客网站案例代码进行重构_09 {
    public static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");

    /**
     * 发布博客
     *
     * @param title   标题
     * @param content 内容
     * @param author  作者
     * @param time    时间
     * @return boolean
     */
    public Mono<String> publishBlog(String id, String title, String content, String author, Date time) {
        Map<String, String> map = new HashMap<>(8);
        map.put(FIELD_ID, id);
        map.put(BlogHelper.FIELD_TITLE, title);
        map.put(BlogHelper.FIELD_CONTENT, content);
        map.put(BlogHelper.FIELD_AUTHOR, author);
        map.put(BlogHelper.FIELD_TIME, sdf.format(time));
        map.put(BlogHelper.FIELD_VIEW_COUNT, String.valueOf(0));
        map.put(BlogHelper.FIELD_LIKE_COUNT, String.valueOf(0));
        map.put(BlogHelper.FIELD_CONTENT_LENGTH, String.valueOf(content.length()));
        // reactor 设置blog信息后，获取博客内容长度

        reactive().incr( KEY_BLOG_COUNT).subscribe();
        return reactive().hmset(KEY_ARTICLE_PREFIX(id), map);
    }

    /**
     * 发布博客
     *
     * @param blog 博客
     * @return
     */
    public Mono<String> publishBlog(Blog blog) {
        return publishBlog(blog.getId(), blog.getTitle(), blog.getContent(), blog.getAuthor(), blog.getTime());
    }

    /**
     * 更新博客
     *
     * @param id      id
     * @param title   标题
     * @param content 内容
     * @param author  作者
     * @param time    时间
     * @return
     */
    public Mono<String> updateBlog(String id, String title, String content, String author, Date time) {
        HashMap<String, String> map = new HashMap<>(4);
        if (StrUtil.isNotBlank(title))
            map.put(FIELD_TITLE, title);
        if (StrUtil.isNotBlank(content)) {
            map.put(FIELD_CONTENT, content);
            map.put(FIELD_CONTENT_LENGTH, String.valueOf(content.length()));
        }
        if (StrUtil.isNotBlank(author))
            map.put(FIELD_AUTHOR, author);
        if (StrUtil.isNotBlank(time.toString()))
            map.put(FIELD_TIME, sdf.format(time));
        return reactive().hmset(KEY_ARTICLE_PREFIX(id), map);
    }

    /**
     * 更新博客
     *
     * @param blog 博客
     * @return
     */
    public Mono<String> updateBlog(Blog blog) {
        return updateBlog(blog.getId(), blog.getTitle(), blog.getContent(), blog.getAuthor(), blog.getTime());
    }

    /**
     * 博客
     *
     * @param id id
     * @return {@link Blog}
     */
    public Flux<List<KeyValue<String, String>>> getBlog(String id) {
        return reactive().hgetall(KEY_ARTICLE_PREFIX(id)).buffer();
    }

    /**
     * 点赞博客
     *
     * @param id id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> likeBlog(String id) {
        return reactive().hincrby(KEY_ARTICLE_PREFIX(id), FIELD_LIKE_COUNT, BlogHelper.ADD_ONE);
    }

    /**
     * 取消 点赞博客
     *
     * @param id id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> cancelLikeBlog(String id) {
        return reactive().hincrby(KEY_ARTICLE_PREFIX(id), FIELD_LIKE_COUNT, BlogHelper.SUB_ONE);
    }

    /**
     * 浏览 博客
     *
     * @param id id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> incrViewBlogCount(String id) {
        return reactive().hincrby(KEY_ARTICLE_PREFIX(id), FIELD_VIEW_COUNT, ADD_ONE);
    }

    /**
     * 博客 助手
     *
     * @author pdd20
     */
    public static class BlogHelper {
        // ================ blog 存储在redis的key ================
        public static final String ARTICLE_PREFIX = "article:";
        public static final String KEY_BLOG_COUNT = "article:count";
        public static final String FIELD_ID = "ID";
        public static final String FIELD_TITLE = "title";
        public static final String FIELD_CONTENT = "content";
        public static final String FIELD_AUTHOR = "author";
        public static final String FIELD_TIME = "time";
        public static final String FIELD_CONTENT_LENGTH = "content_length";
        public static final String FIELD_VIEW_COUNT = "view_count";
        public static final String FIELD_LIKE_COUNT = "like_count";

        public static final long ADD_ONE = 1;
        public static final long SUB_ONE = -1;
        // ========================================================

        public static String KEY_ARTICLE_PREFIX(String id) {
            return ARTICLE_PREFIX + id;
        }

        /**
         * 获取 博客id
         *
         * @return {@link Mono<Long>}
         */
        public static Mono<Long> incrBlogId() {
            return reactive().incr(KEY_BLOG_COUNT);
        }
    }

    /**
     * 博客 实体类
     *
     * @author pdd20
     */
    @Data
    @NoArgsConstructor
    public static class Blog {
        private String id;
        private String title;
        private String content;
        private String author;
        private Date time;

        private long contentLength;
        private long likeCount;
        private long viewCount;

        public Blog(String id) {
            this.id = id;
        }

        public Blog(String id, String title, String content, String author, Date time) {
            this.id = id;
            this.title = title;
            this.content = content;
            this.author = author;
            this.time = time;
        }
    }
~~~





## 测试代码

~~~java
 public static void main(String[] args) {
        对博客网站案例代码进行重构_09 test = new 对博客网站案例代码进行重构_09();
        // 1.发布博客
        String id = UUID.randomUUID().toString();
        test.publishBlog(id, "我喜欢学习redis", "学习redis和lettuce很快乐", "like", new Date()).subscribe(res -> {
            for (int i = 0; i < 10; i++) {
                test.incrViewBlogCount(id).subscribe();
                test.likeBlog(id).subscribe();
            }

            // 2.查看博客
            test.getBlog(id).subscribe(list->{
                Blog blog = BeanUtil.mapToBean(list.stream().collect(Collectors.toMap(KeyValue::getKey, KeyValue::getValue)), Blog.class, false, null);
                System.out.println(blog);
            });

        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
~~~





![image-20210507203433808](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210507203436.png)





# 10.基于令牌的用户登录会话机制

用户登录通过后，会返回浏览器或者客户端一块令牌，同时在redis初始化好一个session会话，后续客户端就会在指定时间范围内发送请求的时候带上令牌，每次令牌和服务端的session校验通过就可以执行请求。

过一段时间后，redis里面的session会话可能过期，这就会导致又要重新登录，虽然带上了令牌，但是一检查发现这个令牌对应在redis中的session已经过期了

```java
public class 基于令牌的用户登录会话机制_10 {
    public static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
    private final static Logger log = getLogger(基于令牌的用户登录会话机制_10.class);
    private static final String KEY_SESSIONS = "sessions:token";
    private static final String KEY_SESSIONS_EXPIRE_TIME = "sessions:expire_time";
    /** session 过期时间 30min */
    public static final long expire = 60 * 30 * 1000;

    public static String FIELD_SESSION_TOKEN(String token) {
        return "session:" + token;
    }

    /**
     * 判断session是否有效
     *
     * @param token 令牌
     * @return boolean
     */
    public boolean isSessionValid(String token) {
        Preconditions.checkNotNull(token);

        String session;
        String expireTimeStr = null;
        Date expireTimeDate;
        try {
            // 判断token对应的session是否存在
            session = reactive().hget(KEY_SESSIONS, FIELD_SESSION_TOKEN(token)).block();
            if (StrUtil.isBlank(session)) return false;

            // 判断token对应的过期时间是否存在
            expireTimeStr = reactive().hget(KEY_SESSIONS_EXPIRE_TIME, FIELD_SESSION_TOKEN(token)).block();
            if (StrUtil.isBlank(expireTimeStr)) return false;

            // 判断是否过期
            expireTimeDate = sdf.parse(expireTimeStr);
            if (new Date().after(expireTimeDate)) return false;
        } catch (ParseException e) {
            log.error("[isSessionValid][ sdf.parse(expireTimeStr)类型转换错误( token:{},expireTimeStr: {} )]", token, expireTimeStr);
        }
        return true;
    }

    /**
     * 初始化会话
     *
     * @param userId 用户id
     * @param token  令牌
     */
    public void initSession(String userId, String token) {
        long expireTimeLong = new Date().getTime() + expire;
        reactive().hset(KEY_SESSIONS, FIELD_SESSION_TOKEN(token), userId).subscribe();
        reactive().hset(KEY_SESSIONS_EXPIRE_TIME, FIELD_SESSION_TOKEN(token), sdf.format(expireTimeLong)).subscribe();
    }
}
```





## test

```java
public static void main(String[] args) {
    基于令牌的用户登录会话机制_10 test = new 基于令牌的用户登录会话机制_10();
    String token = "33333";
    String userId = "123";
    test.initSession(userId, token);

    System.out.println(test.isSessionValid(token));
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }

    System.out.println(test.isSessionValid(token));
}
```

![image-20210507212722546](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210507212731.png)

![image-20210507212726646](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210507212729.png)





# 11.秒杀活动下的公平队列抢购机制

对所有涌入系统的秒杀抢购请求，都放入redis的一个list数据结构里面，进行公平队列排队，然后入队之后等待秒杀结果。专门搞一个消费者从list里面按顺序获取抢购请求，按顺序进行库存扣减，扣减成功就是抢购成功。

公平队列，基于redis的==list==数据结构，搞一个队列，抢购请求都进队，==先入先出==，先来的人先抢购。

~~~
队列：先入先出
lpush  放到最尾
rpop   取出头

栈：后入先出
lpush
lpop
~~~



```java
public class 秒杀活动下的公平队列抢购机制_11 {

    /**
     * 产生秒杀请求
     *
     * @param secKillRequest 秒杀请求
     * @return {@link Mono<Long>}
     */
    public Mono<Long> produceSecLKillRequest(String secKillRequest) {
        return reactive().lpush("sec_kill_request", secKillRequest);
    }

    /**
     * 获取秒杀请求
     *
     * @return {@link Mono<String>}
     */
    public Mono<String> consumeSecKillRequest() {
        return reactive().rpop("sec_kill_request");
    }
}
```





## test

  public static void main(String[] args) {
        秒杀活动下的公平队列抢购机制_11 test = new 秒杀活动下的公平队列抢购机制_11();
        for (int i = 0; i < 10; i++) {
            test.produceSecLKillRequest(String.format("第%s个秒杀请求", i + 1)).block();
        }

```java
    for (int i = 0; i < 10; i++) {
        test.consumeSecKillRequest().subscribe(req -> {
            if (StrUtil.isBlank(req)) {
                throw new RuntimeException();
            }
            System.out.println("req = " + req);
        });
    }
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```



![image-20210509091322110](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509091358.png)





# 12.实现OA系统中的待办事项列表管理

~~~
lindex,lset,linsert,ltrim,lrem
~~~

OA系统，自动化办公系统，就是公司日常运行的办公的日常事务都在OA系统里面来做，请假，审批，开会，项目，任务，==待办事项列表==。

新增

插入

查询

完成

修改待办事项

查询已经完成的待办事项





~~~java
public class 实现OA系统中的待办事项列表管理_12 {

    public static String KEY_TODO_EVENT(String userId) {
        return "todoEvent:" + userId;
    }

    public static String KEY_COMPLETE_TODO_EVENT(String userId) {
        return "competeTodoEvent:" + userId;
    }

    /**
     * 添加todo事件
     *
     * @param userId    用户id
     * @param todoEvent todo事件
     * @return {@link Mono<Long>}
     */
    public Mono<Long> addTodoEvent(String userId, String todoEvent) {
        return reactive().rpush(KEY_TODO_EVENT(userId), todoEvent);
    }

    /**
     * todo事件 列表
     *
     * @param userId     用户id
     * @param pageSize   页面大小
     * @param pageNumber 页码
     * @return {@link Flux<List<String>>}
     */
    public Flux<List<String>> listTodoEvent(String userId, int pageNumber, int pageSize) {
        int start = PageUtil.getStart(pageNumber, pageSize);
        return reactive().lrange(KEY_TODO_EVENT(userId), start, start + pageSize).buffer();
    }

    /**
     * 插入todo事件
     *
     * @param userId    用户id
     * @param todoEvent todo事件
     * @param index     插入索引
     */
    public void insertTodoEvent(String userId, String todoEvent, int index) {
        String key = KEY_TODO_EVENT(userId);

        String pivot = reactive().lindex(key, index).block();
        if (StrUtil.isBlank(pivot)) return;

        reactive().linsert(key, true, pivot, todoEvent).subscribe();

    }

    /**
     * 完成任务的事件
     *
     * @param userId 用户id
     * @param index  指数
     */
    public void completeTodoEvent(String userId, int index) {
        String todoEvent = reactive().lindex(KEY_TODO_EVENT(userId), index).block();
        if (StrUtil.isBlank(todoEvent)) return;

        reactive().lrem(KEY_TODO_EVENT(userId), 1, todoEvent).subscribe(count -> {
            System.out.println("block = " + count);
            if (count > 0) {
                System.out.println("完成" + todoEvent);

                reactive().rpush(KEY_COMPLETE_TODO_EVENT(userId), todoEvent).subscribe();
            } ;
        });
    }

    /**
     * 查看完成的todo事件
     *
     * @param userId     用户id
     * @param pageNumber 页码
     * @param pageSize   页面大小
     * @return {@link Flux<List<String>>}
     */
    public Flux<List<String>> viewCompleteTodoEvent(String userId, int pageNumber, int pageSize) {
        int start = PageUtil.getStart(pageNumber, pageSize);
        return reactive().lrange(KEY_COMPLETE_TODO_EVENT(userId), start, start + pageSize).buffer();
    }
}
~~~





~~~java
public static void main(String[] args) {
    实现OA系统中的待办事项列表管理_12 test = new 实现OA系统中的待办事项列表管理_12();
    String userId = UUID.randomUUID().toString();
    for (int i = 0; i < 20; i++) {
        test.addTodoEvent(userId, String.format("第%s个待办事项", i + 1)).subscribe();
    }

    test.listTodoEvent(userId, 0, 20).subscribe(s -> {
        System.out.println("第一次");
        System.out.println(s);
    });

    int index = 3;
    test.completeTodoEvent(userId, index);

    test.listTodoEvent(userId, 0, 20).subscribe(s -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("第二次");
        System.out.println(s);
    });


    test.insertTodoEvent(userId, "插入到第3个位置的后面", index);

    test.listTodoEvent(userId, 0, 20).subscribe(s -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("第三次");
        System.out.println(s);
    });


    test.viewCompleteTodoEvent(userId, 0, 20).subscribe(s -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("查看完成的");
        System.out.println(s);
    });


    try {
        TimeUnit.SECONDS.sleep(4);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
~~~

![image-20210509105704369](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105721.png)

![image-20210509105708767](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105723.png)

![image-20210509105713219](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105725.png)

![image-20210509105718243](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509105727.png)





# 13.实现网站用户注册时的邮件验证机制

一般来说在注册后台里面，是否在注册的时候里面直接就发送一封邮件呢？不是的，通常来说，在注册成功后，一般会把注册成功的邮件任务发送到一个队列里面，然后直接返回成功给你。

~~~
brpop 可以做成一个阻塞队列的效果（time out）
~~~



~~~java
public class 实现网站用户注册时的邮件验证机制_13 {


    public static String KEY_SEND_MALL_TASK_QUEUE = "send_mall_task_queue";

    public static void main(String[] args) {


        实现网站用户注册时的邮件验证机制_13 test = new 实现网站用户注册时的邮件验证机制_13();

        for (int i = 0; i < 10; i++) {
            String userId = UUID.randomUUID().toString();
            String emailAddress = "98065920@qq.com";
            MallTask mallTask = new MallTask(userId, emailAddress);
            test.emailTaskEnQueue(mallTask).subscribe(s -> {
                System.out.println("s = " + s);
            });
        }

        test.emailTaskDeQueue().subscribe(s -> {
            System.out.println("s.getKey() = " + s.getKey());
            System.out.println("s.getValue() = " + s.getValue());
        });


        try {
            TimeUnit.SECONDS.sleep(7);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 电子邮件任务 入队
     *
     * @param mallTask 购物中心的任务
     * @return {@link Mono<Long>}
     */
    public Mono<Long> emailTaskEnQueue(MallTask mallTask) {
        return reactive().lpush(KEY_SEND_MALL_TASK_QUEUE, JSONUtil.toJsonStr(mallTask));
    }

    public Mono<KeyValue<String, String>> emailTaskDeQueue() {
        return reactive().brpop(5000, KEY_SEND_MALL_TASK_QUEUE);
    }


    @AllArgsConstructor
    @Data
    static class MallTask {
        private String userId;
        private String emailAddress;
    }
~~~





# 14.网站每日UV数据指标去重统计

使用set存放，每次用户登录的时候就添加一次

~~~java
public class 网站每日UV数据指标去重统计_14 {

    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(DatePattern.CHINESE_DATE_PATTERN);
    public static final SimpleDateFormat DATE_TIME_FORMAT = new SimpleDateFormat(DatePattern.CHINESE_DATE_TIME_PATTERN);

    private static final String KEY_USER_ACCESS_COUNT_SET = "USER_ACCESS_COUNT_SET:" + DATE_FORMAT.format(new Date());

    public Mono<Long> addUserAccess(String... userIds) {
        return reactive().sadd(KEY_USER_ACCESS_COUNT_SET, userIds);
    }

    public Long viewUserAccessCount() {
        return reactive().scard(KEY_USER_ACCESS_COUNT_SET).block();
    }
}
~~~





## test

public static void main(String[] args) {
        网站每日UV数据指标去重统计_14 test = new 网站每日UV数据指标去重统计_14();
        for (int i = 1; i <= 100; i++) {
            for (int j = 0; j < 10; j++) {
                test.addUserAccess(String.valueOf(i)).block();
            }
        }

```java
    System.out.println("uv:" + test.viewUserAccessCount());

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```







# 15.博客网站的文章标签管理

在一个博客网站发表一篇文章的时候，都可以自定义给这篇文章打上一些标签，==Java==，==大数据==，==软件架构==等。对于一篇标签来说，标签是不能重复的。标签就直接可以用set来保存。

~~~
smembers key   # 获取标签
sadd key value... # 添加标签
sismember key value # 查看是否有这个标签
srem key value... # 移除标签
~~~





![image-20210509182317711](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509182332.png)



![image-20210509182326780](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210509182328.png)





# 16.朋友圈点赞功能的实现

假设说，你发了一条朋友圈，此时你的好友可能会点赞，取消点赞。好友也可以查看是否对这个朋友圈点赞。你也可以查看这条朋友圈有多少人点赞，哪些人点赞

~~~
sadd # 添加一个好友点赞
srem # 取消点赞
sismember # 你是否对某朋友圈点赞
smembers # 有哪些人点赞
~~~





~~~java
public class 朋友圈点赞功能的实现_16 {

    /**
     * 点赞
     *
     * @param user     用户
     * @param momentId 时刻id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> like(String user, String momentId) {
        return reactive().sadd("moment_like_user_set:" + momentId, user);
    }

    /**
     * 取消点赞
     *
     * @param user     用户
     * @param momentId 时刻id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> disLike(String user, String momentId) {
        return reactive().srem("moment_like_user_set:" + momentId, user);
    }

    /**
     * 是否点赞
     *
     * @param user     用户
     * @param momentId 时刻id
     * @return {@link Mono<Boolean>}
     */
    public Mono<Boolean> hasLike(String user, String momentId) {
        return reactive().sismember(user, momentId);
    }

    /**
     * 点赞的用户
     *
     * @param momentId 时刻id
     * @return {@link Flux<String>}
     */
    public Flux<String> likeUsers(String momentId) {
        return reactive().smembers("moment_like_user_set:" + momentId);
    }

    /**
     * 点赞的数量
     *
     * @param momentId 时刻id
     * @return {@link Mono<Long>}
     */
    public Mono<Long> likeCount(String momentId) {
        return reactive().scard("moment_like_user_set:" + momentId);
    }
}

~~~





## test

~~~java
public static void main(String[] args) {
    朋友圈点赞功能的实现_16 test = new 朋友圈点赞功能的实现_16();
    List<String> likeUsers;
    // 我的朋友
    String u1 = "小明";
    String u2 = "小可";
    String u3 = "小雷";
    String u4 = "小新";

    // 我发了一条朋友圈
    String momentId = "1";

    // u1 u2 u3 u4 对我的朋友圈点赞了
    test.like(u1,momentId).subscribe();
    test.like(u2,momentId).subscribe();
    test.like(u3,momentId).subscribe();
    test.like(u4, momentId).subscribe();

    likeUsers = test.likeUsers(momentId).collect(Collectors.toList()).block();
    System.out.println("第一次："+likeUsers);

    // u3取消点赞
    test.disLike(u3, momentId).subscribe();
    likeUsers = test.likeUsers(momentId).collect(Collectors.toList()).block();
    System.out.println("第二次："+likeUsers);
    // 查看是否点赞了
    test.hasLike(u3, momentId).subscribe(s->{
        System.out.println(s);
    });


    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
~~~







# 17.实现一个网站投票统计程序

用户对投票项进行投票，检查用户是否投票过，查看投票项共有多少人投过。

~~~java
public class 实现一个网站投票统计程序_17 {

    private String KEY_VOTE_TOPIC(String topic) {
        return "vote_topic:" + topic;
    }

    public Mono<Long> vote(String user, String topic) {
        return reactive().sadd(KEY_VOTE_TOPIC(topic), user);
    }

    public Mono<Boolean> hasVote(String user, String topic) {
        return reactive().sismember(KEY_VOTE_TOPIC(topic), user);
    }

    public Mono<Long> voteCount(String topic) {
        return reactive().scard(KEY_VOTE_TOPIC(topic));
    }

    public static void main(String[] args) {
        List<String> topics = Arrays.asList("like 很帅", "like 不帅");

        实现一个网站投票统计程序_17 test = new 实现一个网站投票统计程序_17();
        for (int i = 0; i < 100000; i++) {
            int chose = RandomUtil.randomInt(0, 2);

            test.vote(String.valueOf(i), topics.get(chose)).subscribe();

        }

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }

        test.voteCount(topics.get(0)).subscribe(s -> {
            System.out.println(topics.get(0) + " : " + s);
        });

        test.voteCount(topics.get(1)).subscribe(s -> {
            System.out.println(topics.get(1) + " : " + s);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~





# 18.实现类似微博的社交关系

你可以关注一个博主，取消关注，你可以查看你关注的，也可以查看关注你的



~~~java
public class 实现类似微博的社交关系_18 {

    /**
     * 订阅
     *
     * @param beSubscribedTo 被订阅
     * @param user           用户
     */
    public void subscribe(String beSubscribedTo, String user) {
        reactive().sadd("user:" + user + ":stars", beSubscribedTo).subscribe();
        reactive().sadd("user:" + beSubscribedTo + ":fans", user).subscribe();
    }

    /**
     * 取消订阅
     *
     * @param beSubscribedTo 被订阅
     * @param user           用户
     */
    public void unSubscribe(String beSubscribedTo, String user) {
        reactive().srem("user::" + user + "::stars", beSubscribedTo).subscribe();
        reactive().srem("user::" + beSubscribedTo + "::fans", user).subscribe();
    }

    /**
     * 查看关注的用户
     *
     * @param user 用户
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> stars(String user) {
        return reactive().smembers("user:" + user + ":stars").collect(Collectors.toSet());
    }

    /**
     * 查看关注用户的数
     *
     * @param user 用户
     * @return {@link Mono<Long>}
     */
    public Mono<Long> starsCount(String user) {
        return reactive().scard("user:" + user + ":stars");
    }


    /**
     * 查看粉丝
     *
     * @param user 用户
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> fans(String user) {
        return reactive().smembers("user:" + user + ":fans").collect(Collectors.toSet());
    }

    /**
     * 查看粉丝数
     *
     * @param user 用户
     * @return {@link Mono<Long>}
     */
    public Mono<Long> fansCount(String user) {
        return reactive().scard("user:" + user + ":fans");
    }
}
~~~





## test

~~~java
 public static void main(String[] args) {
        String u1 = "小q";
        String u2 = "小w";
        String u3 = "小z";
        String u4 = "我";

        实现类似微博的社交关系_18 test = new 实现类似微博的社交关系_18();

        // 2、3、4 都关注 1
        test.subscribe(u1, u2);
        test.subscribe(u1, u3);
        test.subscribe(u1, u4);

        // 2、3 关注我
        test.subscribe(u4, u3);
        test.subscribe(u4, u2);
        test.subscribe(u4, u1);

        test.stars(u4).subscribe(s -> {
            System.out.println(u4 + "关注了：" + s);
        });

        test.fans(u4).subscribe(s -> {
            System.out.println(u4 + "的粉丝有：" + s);
        });

        test.fans(u1).subscribe(s -> {
            System.out.println(u1 + "的粉丝有：" + s);
        });


        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
~~~





# 19.微博的共同关注与推荐关注的功能实现

获取我和另一个人的共同好友

获取推荐给我的可以关注的人，我关注的人的关注的人



~~~java
	/**
     * 共同的关注
     *
     * @param u1 me
     * @param u2 myFriend
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> sameStars(String u1, String u2) {
        return reactive().sinter("user:" + u1 + ":stars", "user:" + u2 + ":stars").collect(Collectors.toSet());
    }

    /**
     * 推荐关注（u2向u1推荐->u2中u1没有关注的）
     *
     * @param u1 me
     * @param u2 myFriend
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> recommendStars(String u1, String u2) {
        return reactive().sdiff("user:" + u2 + ":stars", "user:" + u1 + ":stars").collect(Collectors.toSet());
    }
~~~





# 20.实现网站上的抽奖程序

~~~
srandmember 					# 随机弹出指定数量的元素，但不在set中删除
spop							# 删除
~~~



~~~java
public class 实现网站上的抽奖程序_19 {

    /**
     * 加抽奖的候选人
     *
     * @param topic 主题
     * @param user  用户
     * @return
     */
    public Mono<Long> addLotteryDrawCandidate(String topic, String user) {
        return reactive().sadd("lottery_draw:" + topic + ":candidate", user);
    }

    /**
     * 做抽奖
     *
     * @param topic 主题
     * @param count 数
     * @return {@link Mono<Set<String>>}
     */
    public Mono<Set<String>> doLotteryDraw(String topic, int count) {
        return reactive().srandmember("lottery_draw:" + topic + ":candidate", count).collect(Collectors.toSet());
    }
}
~~~



## test

~~~java
public static void main(String[] args) {
        实现网站上的抽奖程序_19 test = new 实现网站上的抽奖程序_19();
        String topic = "随机抽取五位用户送MAC_PRO";
        for (int i = 1; i < 20; i++) {
            test.addLotteryDrawCandidate(topic, String.valueOf(i)).subscribe();
        }
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }

        test.doLotteryDraw(topic,5).subscribe(s->{
            System.out.println("幸运用户(获得mac pro):"+s);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
~~~





# 21.为商品搜索构建反向索引根据关键字

为商品添加索引，sadd给商品添加一个关键词索引，sadd把每个商品添加到每个关键词的商品集合里面去，删除商品是一个反向的过程，使用srem。获取一个商品的所有关键词，smembers，根据某个关键词搜索商品，对每个关键词都smemebers拿到商品集合，然后使用sintern对集合进行交集。



~~~java
public class 为商品搜索构建反向索引根据关键字_20 {

    public void addProductInTagSet(String product, List<String> tags) {
        for (String tag : tags) {
            reactive().sadd("tag:" + tag + ":product", product).subscribe();
        }
    }

    public Mono<Set<String>> listProductByTag(List<String> tags) {
        String[] keys = new String[tags.size()];
        int i = 0;
        for (String tag : tags) {
            keys[i++] = "tag:" + tag + ":product";
        }
        return reactive().sinter(keys).collect(Collectors.toSet());
    }
}
~~~





## test

```java
public static void main(String[] args) {
    为商品搜索构建反向索引根据关键字_20 test = new 为商品搜索构建反向索引根据关键字_20();
    List<String> set = new ArrayList<String>() {
        {
            add("1");
            add("2");
            add("3");
        }
    };
    test.addProductInTagSet("1", set);
    test.addProductInTagSet("2", set);
    test.addProductInTagSet("3", set);
    set.remove("2");
    test.addProductInTagSet("4", set);

    set.add("2");
    test.listProductByTag(set).subscribe(s -> {
        System.out.println(s);
    });

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```





# 22.实现音乐网站的排行榜程序

sorted set,不能有重复的数据，加进去的每个数据都可以带一个分数，它会自动按照分数排序，有序的set。

~~~
zadd
zscore  # 获取分数
zincrby # 加分
zrem    # 删除
zrevrank  # 获取排名
zrevange set 0 100 withscores # 获取前100
~~~





~~~java
public class 实现音乐网站的排行榜程序_21 {

    /**
     * 添加歌曲到指定排行榜中
     *
     * @param music     音乐
     * @param rankTopic 排名的话题
     * @return
     */
    public Mono<Long> addMusicInRankTopic(String music, String rankTopic) {
        return reactive().zadd("rankTopic:" + rankTopic + ":music", 0, music);
    }

    /**
     * 增加音乐的分数
     *
     * @param music     音乐
     * @param score     分数
     * @param rankTopic 排名的话题
     * @return
     */
    public Mono<Double> incrByMusicScore(String music, double score, String rankTopic) {
        return reactive().zincrby("rankTopic:" + rankTopic + ":music", score, music);
    }

    /**
     * 巨鲸音乐网排名话题
     *
     * @return
     */
    public Flux<List<ScoredValue<String>>> top100InRankTopic(String rankTopic) {
        return reactive().zrevrangeWithScores("rankTopic:" + rankTopic + ":music", 0, 100).buffer();
    }
}
~~~





## test

~~~java
 /**
     * 巨鲸音乐网排名话题
     *
     * @return
     */
    public Flux<List<ScoredValue<String>>> top100InRankTopic(String rankTopic) {
        return reactive().zrevrangeWithScores("rankTopic:" + rankTopic + ":music", 0, 100).buffer();
    }

    public static void main(String[] args) {
        实现音乐网站的排行榜程序_21 test = new 实现音乐网站的排行榜程序_21();
        String rankTopic = "Like";
        String m1 = "海浪 红白色乐队-四页景";
        String m2 = "Crawl Outta Love ILLENIUM / Annika Wells - Awake";
        String m3 = "Taking Me Higher ILLENIUM - Awake";
        String m4 = "极恶都市 夏日入侵企画 - 极恶都市";

        test.addMusicInRankTopic(m1, rankTopic).subscribe();
        test.addMusicInRankTopic(m2, rankTopic).subscribe();
        test.addMusicInRankTopic(m3, rankTopic).subscribe();
        test.addMusicInRankTopic(m4, rankTopic).subscribe();

        test.incrByMusicScore(m1, 1, rankTopic).subscribe();
        test.incrByMusicScore(m2, 8.1, rankTopic).subscribe();
        test.incrByMusicScore(m3, 8.8, rankTopic).subscribe();
        test.incrByMusicScore(m4, 5, rankTopic).subscribe();


        test.top100InRankTopic(rankTopic).subscribe(s -> {
            s.forEach(sv -> {
                System.out.println(sv.getValue() + " - " + sv.getScore());
            });
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
~~~





# 23.实现一个新闻推荐机制

在一个zset里面，选择我们指定的分数区间范围内的数据，对这块数据可以进行分页查询。分数就可以设置为时间戳



~~~java
public class 实现一个新闻推荐机制_22 {

    public Flux<ScoredValue<String>> searchNews(Integer minTimestamp, Integer maxTimestamp, int pageNo, int pageSize) {
        return reactive().zrevrangebyscoreWithScores("news",
                Range.create(minTimestamp, maxTimestamp),
                Limit.create(
                        PageUtil.getStart(pageNo, pageSize),
                        PageUtil.getEnd(pageNo, pageSize)));
    }

    public Mono<Long> addNew(String news, long timeStamp) {
        return reactive().zadd("news", timeStamp, news);
    }

    public static void main(String[] args) {
        实现一个新闻推荐机制_22 test = new 实现一个新闻推荐机制_22();

        for (int i = 0; i < 20; i++) {
            test.addNew(String.valueOf(i + 1), i + 1).subscribe();
        }

        test.searchNews(0, 20, 1, 10).subscribe(s->{
            System.out.println(s);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~







# 24.大数据商品关系推荐机制

买了一个商品，他会给你一个列表，购买过次商品的顾客也同时购买了其他 xx 商品。对每个顾客，每次购买后，都遍历他之前购买过的所有商品，对每个商品都维护一个同时购买的其他商品的数量，然后如果看到某个商品购买的人还购买了其他哪些商品，用zrevange





~~~java
public class 大数据商品关系推荐机制_23 {


    /**
     * 继续购买
     *
     * @param product     产品
     * @param nextProduct 下一个产品
     * @return {@link Mono<Double>}
     */
    public Mono<Double> continueToBuy(String product, String nextProduct) {
        return reactive().zincrby("product:" + product + "continueToBuy", 1, nextProduct);
    }

    /**
     * 推荐
     *
     * @param product 产品
     * @return {@link Flux<ScoredValue<String>>}
     */
    public Flux<ScoredValue<String>> recommended(String product) {
        return reactive().zrevrangeWithScores("product:" + product + "continueToBuy", 0, 3);
    }
}
~~~





# 25.实现网站搜索框的自动补全功能

![image-20210513192942603](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210513192955.png)



~~~java
public class 实现网站搜索框的自动补全功能_24 {

    public void search(String keyword) {
        char[] chars = keyword.toCharArray();

        StringBuilder potentialKeyword = new StringBuilder("");
        for (char c : chars) {
            potentialKeyword.append(c);
            reactive().zincrby("potential_keyword:" + potentialKeyword + ":keywords", RandomUtil.randomDouble(0,1), keyword).subscribe();
        }
    }

    public Flux<List<String>> getAutoCompleteList(String potentialKeyword) {
        return reactive().zrevrange("potential_keyword:" + potentialKeyword + ":keywords", 0, 5).buffer();
    }

    public static void main(String[] args) {
        实现网站搜索框的自动补全功能_24 test = new 实现网站搜索框的自动补全功能_24();

        test.search("我爱李可");
        test.search("我爱中国");
        test.search("我很喜欢redis");
        test.search("我不喜欢看电视");
        test.search("我很喜欢学习spark");


        test.getAutoCompleteList("我").subscribe(s->{
            System.out.println("第一次自动补传:"+s);
        });

        test.getAutoCompleteList("我很").subscribe(s->{
            System.out.println("第二次自动补传:"+s);
        });

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
~~~







# 26.基于HyperLogLog的网站UV统计程序

hyperloglog,数据结构+概率算法组合而成。去重统计，近似数。一个hyperloglog占用12kb的内存，所以不需要来统计uv。

~~~bash
pafdd
pfcount
~~~



![image-20210513200034243](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20210513200041.png)