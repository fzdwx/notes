# 一.适配器模式：Adapter

**介绍：**将某个类的接口转换成客户端期望的另一个接口表现，组要目的是兼容性，让原本接口不匹配不能一起工作的两个类可以协同工作，又称为包装器（Wrapper）



## 1.类适配器

**组成：**

1.  Src（源）：被适配的 ，必须是类
2.  Dst（需要适配的结果），必须是接口
3.  Adpater：适配器，把Src转成Dst

**实现：**==适配器需要继承源类，实现目标接口==



==src==

```java
public class Voltage200 {
    protected int voltage;
    public int isVoltage200() {
        voltage = 200;
        return voltage;
    }
}
```



==Dst==

```java
public interface Voltage50 {
    int isVoltage50();
}
```



==Adpater==

```java
public class Voltage200To50Adapter extends Voltage200 implements Voltage50 {
    @Override
    public int isVoltage50() {
        //进行适配
        int v200 = isVoltage200();
        voltage = v200 / 4;
        return voltage;
    }
}
```



==测试==

```java
public class test {
    public static void main(String[] args) {
        Voltage50 v50 = new Voltage200To50Adapter();
        int voltage50 = v50.isVoltage50();
        System.out.println(voltage50);
    }
}
```



## 2.对象适配器

**怎么实现：**==把继承Src类的方法改为组合==



==适配器==

```java
public class Voltage200To50Adapter implements Voltage50 {
    private Voltage200 v200;

    public Voltage200To50Adapter(Voltage200 voltage200) {
        this.v200 = voltage200;
    }

    @Override
    public int isVoltage50() {
        int voltage200 = v200.isVoltage200();
        v200.showVoltage();
        v200.voltage = voltage200 / 4;
        v200.showVoltage();
        return v200.voltage;
    }
}
```

==测试==

```java
public class test {
    public static void main(String[] args) {
        Voltage50 v50 =new Voltage200To50Adapter(new Voltage200());
        v50.isVoltage50();
    }
}
```

## 3.接口适配器

==所有目标类的父类==

```java
abstract public class Voltage {
    abstract public int isVoltage();
}
```

==目标类==

```java
public class Voltage100 extends Voltage {
    @Override
    public int isVoltage() {
        return 100;
    }
}
public class Voltage200  extends Voltage{
    @Override
    public int isVoltage() {
        return 200;
    }
}
```

==适配的结果==

```java
public interface Voltage5 {
    int isVoltage5();
}
```

==适配器==

```java
public class VoltageAdapter implements Voltage5 {
    private Voltage voltage;

    public VoltageAdapter(Voltage voltage) {
        this.voltage = voltage;
    }
    @Override
    public int isVoltage5() {
        int voltage = this.voltage.isVoltage();
        int sta = voltage / 5; //  200   40     100  20
        return voltage / sta;
    }
}
```

==测试==

```java
public class test {
    public static void main(String[] args) {
        VoltageAdapter adapter = new VoltageAdapter(new Voltage200());
        int voltage5 = adapter.isVoltage5();
        System.out.println(voltage5);
    }
}
```



#### 老师讲的

```java
public abstract class Adapter implements A {

    public void a0() {

    }

    public void a1() {

    }

    public void a2() {

    }

    public void a3() {

    }

    public void a4() {

    }
}

public class B extends Adapter {

    public void a2() {
        super.a2();
    }
}
```





## 4.SpirngMVC中的HandlerAdapter







# 二、桥接模式：Bridge

将实现和抽象放在两个不同的类才层次中，使两个层次可以独立改变，基于==类的最小设计原则==，使用封装，聚合，继承等行为让不同的类承担不同的职责，主要特点是把==抽象(Abstrancion)与行为实现(Imolementation)分开，从而可以保持各部分的独立性以及应对他们的功能扩展==

-   Abstraction：维护了 Implementor 类，两者是聚合关系，Abstraction 充当桥接类。
-   RefinedAbstraction：是 Abstraction 抽象类的子类。
-   Implementor：行为实现类的接口。
-   ConcreteImplementorA/ConcreteImplementorA：行为的具体实现类。

![image-20200816111043084](D:\作业\笔记\设计模式\image\image-20200816111043084.png)







### 手机品牌类-抽象类

聚合手机软件类

==父类==

```java
public abstract class AbstractHandset {
    protected HandsetSoft hs;

    public AbstractHandset(HandsetSoft hs) {
        this.hs = hs;
    }
    public  void start(){};
}
```

==小米==

```java
public class HandsetMi extends AbstractHandset {
    public HandsetMi(HandsetSoft hs) {
        super(hs);
    }
    @Override
    public void start() {
        this.hs.start();
    }
}
```

==华为==

```
public class HandsetHuaWei extends AbstractHandset {
    public HandsetHuaWei(HandsetSoft hs) {
        super(hs);
    }
    @Override
    public void start() {
        this.hs.start();
    }
}
```





### 手机软件-接口

==父接口==

```java
public interface HandsetSoft {
    void start();
}
```

==音乐==

```java
public class HandsetMusic implements HandsetSoft {
    @Override
    public void start() {
        System.out.println("开始听歌");
    }
}
```

==游戏==

```java
public class HandsetGame implements HandsetSoft {

    @Override
    public void start() {
        System.out.println("开始玩手机游戏");
    }
}
```



### 测试

```java
public class Client {
    public static void main(String[] args) {
        AbstractHandset hw = new HandsetHuaWei(new HandsetGame());
        hw.start();
    }
}
```

### 小结

桥接模式，实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。**桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本**。

桥接模式要求正确识别出系统中两个独立变化的维度(抽象和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。



# 三、装饰者模式：Decorator

装饰着模式的组成：

1.  ==抽象构件角色（Component）==：定义一个抽象接口，以规范准备接收附加责任的对象

2.   ==具体构件角色(Concrete Component)==：这是被装饰者，定义一个将要被装饰增加功能的类。

3.  ==装饰角色(Decorator)==：持有一个构件对象的实例，并定义了抽象构件定义的接口。

4.  ==具体装饰角色(Concrete Decorator)==：负责给构件添加增加的功能。



## Component

所有相关类的父类

```java
public abstract class Drink {
    private String des;
    private double price;
    public abstract double cost();
```

咖啡类的父类

```java
public  abstract class Coffee extends Drink {
    @Override
    public double cost() {
        return super.getPrice();
    }
}
```



## Concrete Component-被装饰者

```java
public class AmericanCoffee  extends Coffee {
    public AmericanCoffee() {
        setDes("美式咖啡");
        setPrice(5);
    }
}
public class ItalianCoffee  extends Coffee {
    public ItalianCoffee() {
        setDes("意大利咖啡");
        setPrice(10);
    }
}
public class LatteCoffee  extends Coffee {
    public LatteCoffee() {
        setDes("拿铁咖啡");
        setPrice(9);
    }
}
```



## Decorator-装饰者

```java
public abstract class Decorator extends Drink {
    private Drink drink;
    public Decorator(Drink drink) {
        this.drink = drink;
    }
    @Override
    public double cost() {
        return super.getPrice()+drink.cost();
    }
    @Override
    public String getDes() {
        return super.getDes()+":"+ super.getPrice()+"&&" +drink.getDes();
    }
}
```



## Concrete Decorator-实际的装饰者

```java
public class Chocolate extends Decorator {
    public Chocolate(Drink drink) {
        super(drink);
        setDes("巧克力");
        setPrice(1);
    }
}
public class Milk extends Decorator {
    public Milk(Drink drink) {
        super(drink);
        setDes("牛奶");
        setPrice(2);
    }
}
public class Sugar extends Decorator {
    public Sugar(Drink drink) {
        super(drink);
        setDes("糖");
        setPrice(0.5);
    }
}
```



## 测试：

```java
public class CofferBur {
    public static void main(String[] args) {
        //1.点一份拿铁咖啡
        Drink order = new LatteCoffee();
        System.out.println(order.cost());
        System.out.println(order.getDes());
        //2.加入一份牛奶
        System.out.println("========加入牛奶=========");
        order = new Milk(order);
        System.out.println(order.cost());
        System.out.println(order.getDes());
        //3.加入巧克力
        System.out.println("========加入巧克力=========");
        order = new Chocolate(order);
        System.out.println(order.cost());
        System.out.println(order.getDes());
        //4.加入糖
        System.out.println("========糖=========");
        order = new Sugar(order);
        System.out.println(order.cost());
        System.out.println(order.getDes());
    }
}
#####################################################
9.0
拿铁咖啡
========加入牛奶=========
11.0
牛奶:2.0&&拿铁咖啡
========加入巧克力=========
12.0
巧克力:1.0&&牛奶:2.0&&拿铁咖啡
========糖=========
12.5
糖:0.5&&巧克力:1.0&&牛奶:2.0&&拿铁咖啡
```

