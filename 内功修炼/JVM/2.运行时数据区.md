![image-20200928153607955](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928153608.png)



![image-20200928154456602](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928154456.png)



![image-20200928154757784](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928154757.png)

## 1.jvm线程说明

每个线程：程序计数器，栈，本地栈

线程间：堆，堆外内存(永久代或源空间，代码缓存)

![image-20200928155706327](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928155706.png)

![image-20200928160443899](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928160444.png)



## 2.pc寄存器(程序计数器)

用于存储下一跳指令的地址

-   它是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域
-   在JVM规范，每个线程都有它自己的程序计数器，是线程私有的，声明舟曲和线程一致
-   任何时间一个线程都只有一个方法在执行，也就所谓的==当前方法==。程序计数器会存储当前线程正在执行的java方法的jvm指令地址；
-   如果是==native==方法，则是未指定值(undefned)

![image-20200928161349960](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928161350.png)

![image-20200928162907232](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928162907.png)



## 3.栈(虚拟机栈)

有不少开发人员一提到java内存结构，就会非常粗粒度的将JVM中的内存区理解为仅有Java堆(heap)和java栈(stack)?为什么？

==栈==是运行时的单位，而==堆==是存储的单位。

栈是解决程序运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么放，放在哪。

​					==栈==																							       ==堆==

![image-20200929105413148](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929105420.png)

​		==字节码指令==



### a.概念

每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个栈帧(stack frame)，对应这一次次方法的调用

### b.作用

主管java程序的运行，保存方法的局部变量(==8种数据类型，对象的引用地址==)、部分结果、参与方法的调用和返回

-   局部变量 vs 成员变量或属性
-   基本数据类型变量 vs 引用类型变量(类，数组，接口)



```java
public class JVMStackDemo {
    public static void main(String[] args) {
        JVMStackDemo js = new JVMStackDemo();
        js.a();
    }
    public void  a (){
        int a = 10;
        System.out.println("a方法被调用");
        b();
    }
    public void  b (){
        int b = 20;
        System.out.println("b方法被调用");
    }
}
```

![image-20200929112423286](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929112423.png)



### c.特点

-   栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
-   JVM对栈的操作只有2个：
    -   每个方法的执行：进栈
    -   方法执行后的：出栈
-   栈不存在垃圾回收
-   存在OOM

![image-20200929112932175](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929112932.png)

### d.开发中的常见的异常

-   Java虚拟机允许==Java栈的大小是动态的或者是固定不变的==

    -   如果采用固定大小的Java虚拟栈， 那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈运行的最大容量，那么java虚拟机会抛出==StackOverflowError==
    -   如果Java虚拟机栈可以动态扩展，但是在动态扩展的时候无法申请到足够的内存，那么就会抛出==OutOfMemoryError==

    

### f.栈中存储什么

-   每个线程都有自己的栈，栈中的数据都是以==栈帧(stack frame)==的格式存在
-   每个方法都是有一个对应的栈帧
    -   栈帧是一个内存区域，是一个数据集，有方法执行过程中的各种数据信息



### g.栈运行原理

-   jvm直接对java栈的操作只有两个，就是对栈帧的==压栈==和==出栈==，遵循==先进后出==的原则
-   在一个活动的线程中，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(==栈顶栈帧==)，和其对应的是当前方法，定义这个方法的类就是当前类
-   执行引擎所需的字节码指令只针对当前栈帧操作
-   如果这个方法调用了其他方法，对应的新的栈帧就会被创建，成为新的栈顶栈帧



## 4.栈帧的结构

-   ==局部变量表==（local variables）
-   ==操作数栈==（operand stack）或表达式栈
-   动态链接（dynamic linking）或指向运行时常量池的方法引用
-   方法返回地址（return address）或方法正常退出或异常退出的定义
-   一些附加信息

![image-20200929122226743](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929122226.png)



### a.局部变量表

局部变量表也叫局部变量数组或本地变量表

-   ==定义为一个数组，主要用于存储方法参数和定义在方法体内的局部变量==，这些数据类型包括各类基本数据类型，对象引用(reference)，以及返回地址类型(returnAddress)类型
-   局部变量表是线程私有的，所以不存在==数据安全==问题
-   ==局部变量表所需的容量大小是在编译期确定的==，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的
-   局部变量表的最基本存储单元是==sold==（变量槽）
    -   ![image-20200930100953225](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930100953.png)
    -   ![image-20200930101137003](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930101137.png)

```java
public class LocalVariablesDemo {
    private  int  count = 0;

    public static void main(String[] args) {
        LocalVariablesDemo lvd = new LocalVariablesDemo();
        int num = 10;
        lvd.test1();
    }

    private void test1() {
        String name = "like";
    }
}
```

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930095607.png)

![image-20200930095643718](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930095643.png)



### b.操作数栈

![image-20200930110811688](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930110811.png)

![image-20200930114057774](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930114057.png)



### c.动态链接(指向运行时常量池的方法引用)

-   每一个栈帧内部都包含一个指向==运行时常量池==中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现==动态连接==。比如==invokedynamic==指令
-   在Java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么==动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用==。