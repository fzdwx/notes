![image-20200928153607955](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928153608.png)



![image-20200928154456602](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928154456.png)



![image-20200928154757784](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928154757.png)

## 1.jvm线程说明

每个线程：程序计数器，栈，本地栈

线程间：堆，堆外内存(永久代或源空间，代码缓存)

![image-20200928155706327](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928155706.png)

![image-20200928160443899](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928160444.png)



## 2.pc寄存器(程序计数器)

用于存储下一跳指令的地址

-   它是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域
-   在JVM规范，每个线程都有它自己的程序计数器，是线程私有的，声明舟曲和线程一致
-   任何时间一个线程都只有一个方法在执行，也就所谓的==当前方法==。程序计数器会存储当前线程正在执行的java方法的jvm指令地址；
-   如果是==native==方法，则是未指定值(undefned)

![image-20200928161349960](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928161350.png)

![image-20200928162907232](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200928162907.png)



## 3.栈(虚拟机栈)

有不少开发人员一提到java内存结构，就会非常粗粒度的将JVM中的内存区理解为仅有Java堆(heap)和java栈(stack)?为什么？

==栈==是运行时的单位，而==堆==是存储的单位。

栈是解决程序运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么放，放在哪。

​					==栈==																							       ==堆==

![image-20200929105413148](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929105420.png)

​		==字节码指令==



### a.概念

每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个栈帧(stack frame)，对应这一次次方法的调用

### b.作用

主管java程序的运行，保存方法的局部变量(==8种数据类型，对象的引用地址==)、部分结果、参与方法的调用和返回

-   局部变量 vs 成员变量或属性
-   基本数据类型变量 vs 引用类型变量(类，数组，接口)



```java
public class JVMStackDemo {
    public static void main(String[] args) {
        JVMStackDemo js = new JVMStackDemo();
        js.a();
    }
    public void  a (){
        int a = 10;
        System.out.println("a方法被调用");
        b();
    }
    public void  b (){
        int b = 20;
        System.out.println("b方法被调用");
    }
}
```

![image-20200929112423286](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929112423.png)



### c.特点

-   栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
-   JVM对栈的操作只有2个：
    -   每个方法的执行：进栈
    -   方法执行后的：出栈
-   栈不存在垃圾回收
-   存在OOM

![image-20200929112932175](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929112932.png)

### d.开发中的常见的异常

-   Java虚拟机允许==Java栈的大小是动态的或者是固定不变的==

    -   如果采用固定大小的Java虚拟栈， 那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈运行的最大容量，那么java虚拟机会抛出==StackOverflowError==
    -   如果Java虚拟机栈可以动态扩展，但是在动态扩展的时候无法申请到足够的内存，那么就会抛出==OutOfMemoryError==

    

### f.栈中存储什么

-   每个线程都有自己的栈，栈中的数据都是以==栈帧(stack frame)==的格式存在
-   每个方法都是有一个对应的栈帧
    -   栈帧是一个内存区域，是一个数据集，有方法执行过程中的各种数据信息



### g.栈运行原理

-   jvm直接对java栈的操作只有两个，就是对栈帧的==压栈==和==出栈==，遵循==先进后出==的原则
-   在一个活动的线程中，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(==栈顶栈帧==)，和其对应的是当前方法，定义这个方法的类就是当前类
-   执行引擎所需的字节码指令只针对当前栈帧操作
-   如果这个方法调用了其他方法，对应的新的栈帧就会被创建，成为新的栈顶栈帧



## 4.栈帧的结构

-   ==局部变量表==（local variables）
-   ==操作数栈==（operand stack）或表达式栈
-   动态链接（dynamic linking）或指向运行时常量池的方法引用
-   方法返回地址（return address）或方法正常退出或异常退出的定义
-   一些附加信息

![image-20200929122226743](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200929122226.png)



### a.局部变量表

局部变量表也叫局部变量数组或本地变量表

-   ==定义为一个数组，主要用于存储方法参数和定义在方法体内的局部变量==，这些数据类型包括各类基本数据类型，对象引用(reference)，以及返回地址类型(returnAddress)类型
-   局部变量表是线程私有的，所以不存在==数据安全==问题
-   ==局部变量表所需的容量大小是在编译期确定的==，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的
-   局部变量表的最基本存储单元是==sold==（变量槽）
    -   ![image-20200930100953225](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930100953.png)
    -   ![image-20200930101137003](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930101137.png)

```java
public class LocalVariablesDemo {
    private  int  count = 0;

    public static void main(String[] args) {
        LocalVariablesDemo lvd = new LocalVariablesDemo();
        int num = 10;
        lvd.test1();
    }

    private void test1() {
        String name = "like";
    }
}
```

![](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930095607.png)

![image-20200930095643718](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930095643.png)



### b.操作数栈

![image-20200930110811688](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930110811.png)

![image-20200930114057774](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20200930114057.png)



### c.动态链接(指向运行时常量池的方法引用)

-   每一个栈帧内部都包含一个指向==运行时常量池==中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现==动态连接==。比如==invokedynamic==指令
-   在Java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么==动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用==。



#### 方法的调用

绑定的是一个字段，方法或者类在符号引用被替换为直接引用的过程

-   早期绑定：

    被调用的==目标方法如果在编译期可知，且运行期间保持不变时==，就可以将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用

-   晚期绑定：

    被调用的==目标方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法==



##### 非虚方法：

如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法就是==非虚方法==

-   静态方法，私有方法，final方法，实例的构造器，父类方法都是非虚方法
-   其他都是虚方法



##### 调用指令

-   普通调用指令
    1.  invokestatic:调用静态方法，解析阶段确定唯一方法版本
    2.  invokepecial:调用< init >方法，私有方法，父类方法，解析阶段确定唯一版本
    3.  invokevirtual:调用所有虚方法
    4.  invokeinterface:调用接口方法

-   动态调用指令：

    5.  invokedynamic：动态解析出需要调用的方法，然后执行

        ![image-20201002093502690](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201002093509.png)

    前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持用户确定方法版本。其中==invocestatic指令和invocespecial指令调用的方法为非虚方法==，其他的是虚方法(除了final修饰的)

    

##### 虚方法表

为了提高性能，JVM采用在类的方法区建立一个虚方法表(非虚方法不会存在)来实现，使用索引表来代替查找。

-   每个类中都有一个虚方法表，保存着各个方法的实际入口
-   在类的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕





### d.方法返回地址

-   存放调用该方法的pc寄存器的值
-   一个方法的结束，有两种方式：
    -   正常执行完毕
    -   出现异常，非正常退出
-   无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，==调用者的pc计数器的值作为返回地址，即调用该方法的指令的吓一跳指令的地址==。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分的信息。

正常退出和异常退出的区别：==通过异常完成出口退出的不会给他的上层调用者参数任何的返回值==。

两种退出方法：

1.  执行引擎遇到任意一个方法返回的字节码指令(return),会有返回值传递给上层的方法调用者——正常退出
    -   一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
    -   在字节码指令中，返回指令包含iretrun（返回值是boolean，byte，chart，short，int类型时使用），lretrun，freturn，dreturn和areturn。还有一个retrun指令共声明为void的方法，实例化方法，类和接口的初始化方法使用



### e.一些附加信息





## 5.栈的相关面试题

### 1.举例栈溢出的情况

stackoverflowError

-   通过-Xss设置栈的大小
-   一个方法内调用本身，无限递归，一直创建栈帧，撑爆了栈空间



### 2.调整栈大小，就能保证不出现溢出吗？

不能，可以使StackOverflowError出现的晚一点



### 3.垃圾回收会涉及到栈空间吗？

不会，所以不能用垃圾回收来避免StackOverflowError



### 4、分配的栈内存越大越好吗？

 不是

### 5.方法中定义的局部变量是否线程安全

安全





## 6.本地方法栈

![image-20201002145721733](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201002145721.png)

![image-20201002145921246](https://gitee.com/likeloveC/picture_bed/raw/master/img/8.26/20201002145921.png)