

# 206_反转链表

https://leetcode-cn.com/problems/reverse-linked-list/

## 双指针迭代

​				我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。
​				第二个指针 cur 指向 head，然后不断遍历 cur。
​				每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
​				都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。
​		动画演示如下：



![image-20201001214238759](https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-迭代.gif)

动画演示中其实省略了一个tmp变量，这个tmp变量会将cur的下一个节点保存起来，考虑到一张动画放太多变量会很混乱，所以我就没加了，具体详细执行过程，请点击下面的幻灯片查看。

幻灯片地址：

https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/

~~~java
public ListNode reverseList2(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        //保存curr的下一个节点
        ListNode temp = curr.next;

        //后移prev
        curr.next = prev;
        prev = curr;

        //后移curr
        curr = temp;
    }
    return prev;
}
~~~



## 递归

递归的两个条件：

1.  终止条件是当前节点或者下一个节点==null

2.  在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句

    ~~~java
    head.next.next = head
    ~~~

很不好理解，其实就是 ==head 的下一个节点指向head。==
递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode newHead = reverseList(head.next);

    //如果链表是 1->2->3->4->5，那么此时的cur就是5
    //而head是4，head的下一个是5，下下一个是空
    //所以head.next.next 就是5->4
    head.next.next = head;
    //防止链表循环，需要将head.next设置为空
    head.next = null;
    
    return newHead;
}
```

