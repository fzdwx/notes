# 1.单一职责：

>   一个类只负责一项职责



# 2.接口隔离：

>   一个类实现的一个接口，最好都是这个类需要的方法





# 3.依赖倒转：

>   1.  高层模块不应该依赖底层模块，都应依赖抽象类，接口
>   2.  抽象不应该依赖细节，细节应该依赖抽象
>   3.  面向接口编程
>   4.  使用接口和抽象类的目的是定制好规范，不涉及具体的操作
>   5.  以抽象为基础搭建的架构比细节为基础的架构稳定





# 4.里氏替换：

>   1.  引用基类的地方必须能透明的使用其子类的对象
>   2.  子类中尽量不要重写父类的方法
>
>   



# 5.开闭原则：OCP

>   对扩展开放（开发），对修改关闭（使用）





# 6.迪米特：最少知道原则

>   1.  一个对象应该对其他对象保持最少的了解
>   2.  一个类对自己依赖的类知道的越少越好
>   3.  被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外提供public方法，不对外泄露任何信息





# 7.合成复用

>   尽量使用合成、聚合的方式，而不是使用继承









# 一、uml类图

## 1.依赖：

只要一个类中用到了对方，那么他们就存在依赖关系



## 2.泛化：

继承



## 3.实现：

实现一个接口

>   实现接口：使用 ==空心三角形 + 虚线== 表示

![image-20200810154407771](D:\作业\笔记\设计模式\image\image-20200810154407771.png)

## 4.关联：

**导航性,双向关系，或单项关系**,**企鹅需要“知道” 气候的变化**.

>   当一个类“知道” 另一个类的时候，可以使用==关联,关联关系用实线箭头表示==。

![image-20200810154520455](D:\作业\笔记\设计模式\image\image-20200810154520455.png)

## 5.聚合：

**每只大雁都是属于一个雁群，一个雁群可以有多只大雁**。

**聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。**聚合关系用 **空心的菱形 + 实线箭头** 来表示。”

![image-20200810154700131](D:\作业\笔记\设计模式\image\image-20200810154700131.png)

![image-20200810154800710](D:\作业\笔记\设计模式\image\image-20200810154800710.png)



## 6.组合

**合成(Composition,也有翻译成‘组合’的)是一种强的‘拥有’关系，体现了严格的部分和整体的关系**，==不可分割的聚合关系是组合关系==

![image-20200810154959861](D:\作业\笔记\设计模式\image\image-20200810154959861.png)





# 二、单例模式：singleton

使用场景：

**需要频繁进行创建和销毁的对象，创建对象时消耗过多的资源（重量级对象），工具类对象，频繁访问数据库文件的对象（数据源，session工厂）**

## 1.饿汉式-01-直接创建

>   1.  **构造器私有化**
>   2.  **类的内部创建对象**
>   3.  **一个公共的静态方法获取这个对象**  ==getInstance()==;

优点：

**写法简单，在类装载的时候就完成了实例化，避免了线程同步问题**

缺点：

**没有达到懒加载的效果，如果这个对象没有使用过，就会造成内存浪费**

总结：

**可以使用，可能会浪费资源**

```java
public class Hungry {
  private Hungry() {
      //1.私有化构造器
  }
  //2.创建对象
  private static  Hungry instance = new Hungry();
  //3.返回实例化对象
  public Hungry getInstance() {
      return instance;
  }
}
```



## 2.饿汉式-02-使用静态代码块

```java
class Hungry2 {
    private Hungry2() { }
    private static  Hungry2 instance;
    //静态代码块创建
    static {
        instance = new Hungry2();
    }
    public Hungry2 getInstance() {
        return instance;
    }
}
```





## 3.懒汉式-01-线程不安全

>   ==在getInstance()方法中判断是否需要创建对象==

优点：

**起到了懒加载的效果，只能在单线程下使用**

缺点：

**在多线程环境下，判断语句块可能还没有来得及执行就会创建多个对象实例**

总结：

**不要使用**

```java
class Lazy1 {
    private Lazy1() { }
    private static Lazy1 instance;
    public Lazy1 getInstance() {
        if (instance == null) {
            instance = new Lazy1();
        }
        return instance;
    }
}
```



## 4.懒汉式-02-线程安全

>   ==在getInstance()上加锁==

**效率太慢，不推荐使用**

```java
class Lazy2 {
    private Lazy2() { }
    private static Lazy2 instance;
    //加锁
    public synchronized Lazy2 getInstance() {
        if (instance == null) {
            instance = new Lazy2();
        }
        return instance;
    }
}
```

## 5.懒汉式-03-双重检查

>   **进行两次==if (instance == null)==的检查保存了线程安全,在instance上加==volatile==**

优点

**保证线程安全，懒加载，效率较高**

推荐使用 

****

```java
/* 双重检查 */
class Lazy3 {
    private Lazy3() { }
    private static volatile Lazy3 instance;
    public  Lazy3 getInstance() {
        //第一次检查
        if (instance == null) {
            synchronized (this) {
                //第二次检查
                if (instance == null) {
                    instance = new Lazy3();
                }
            }
        }
        return instance;
    }
}
```





## 6.静态内部类

>   **在类中写一个静态内部类private static class singletonInstance{}来获取当前类的实例对象**

优点：

**1.采用了类装载的机制保证初始化实例时只有一个线程**

**2.singletonInstance{}不会在StaticInnerClass被加载时被加载，而是在调用==getInstance()==方法后才会加载，从而完成对象的实例化**

**3.jvm保证的线程的安全性，进行类的初始化时，别的线程是无法进入的**

总结：

**推荐使用**

```java
class StaticInnerClass {
    private StaticInnerClass(){}
    //静态内部类
    private static class singletonInstance{
        private static  StaticInnerClass instance= new StaticInnerClass();
    }
    public  StaticInnerClass getInstance() {
        return singletonInstance.instance;
    }
}
```



## 7.枚举

优点：

**能避免多线程同步问题，能防止反序列化重新创建对象**

总结：

**墙裂推荐**

```java
class Singleton {
    public static void main(String[] args) {
        Singleton2 singleton2 = Singleton2.instance;
        Singleton2 singleton1 = Singleton2.instance;
    }
}

enum Singleton2 {
    //实例化对象
    instance;
}
```



## 8.jdk中的单例模式-饿汉式-Runtime.class



```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    public static Runtime getRuntime() {
        return currentRuntime;
    }
    private Runtime() {}
```







# 三、工厂模式

## 1.简单工厂模式-静态工厂模式

**简单工厂模式：**属于创建型模式，是由一个工厂对象决定创建出哪一种产品类的实例，是最简单使用的模式。定义了一个创建对象的类，由这个类来**封装实例化对象的行为**。当我们会使用到大量的创建某种，某类或者某批对象时，使用工厂模式。

**汽车工厂**

```java
public class CarFactory {
   public static car createCar (String carType){
      car car= null;
      if (carType.equals("五菱宏光")) {
         car = new wlhg();
      }else if (carType.equals("宝马")) {
         car = new BMW();
      } else if (carType.equals("特斯拉")) {
         car = new Tesla();
      }
      return car;
   }
}
```

**汽车**

```java
public interface car {}

public class wlhg implements car {
    public wlhg() {
        System.out.println("您买了一辆五菱宏光");
    }
}
public
    class BMW implements car {
    public BMW() {
        System.out.println("您买了一辆宝马");
    }
}

public class Tesla implements car{
    public Tesla() {
        System.out.println("您买了一辆特斯拉");
    }
}

```

**汽车商店**

```java
public class CarShop {
    public static void main(String[] args) {
        CarFactory.createCar("五菱宏光");
    }
}
```



## 2.工厂方法模式：

**设计方案：**把项目的实例化功能抽象成抽象方法，定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将==对象的实例化推迟到子类==

**结构：**

*   抽象工厂：提供了创建产品的接口，通过访问具体的工厂方法创建产品createXXX
*   具体工厂：实现抽象工厂的抽象方法，完成产品的创建
*   抽象产品：定义产品规范，描述产品功能
*   具体产品：实现产品角色定义的接口



>   一个工厂类专门创建一个产品

==car==

```java
public interface Car {
    void run();
}
public class ACar implements Car{
    @Override
    public void run() {
        System.out.println("A汽车跑起来了");
    }
}
public class BCar implements Car{
    @Override
    public void run() {
        System.out.println("B汽车跑起来了");
    }
}
```

==工厂==

```java
public interface AbstractCarFactory {
   Car createCar();
}
public class ACarFactory implements AbstractCarFactory{
    @Override
    public Car createCar() {
        return new ACar();
    }
}
public class BCarFactory implements AbstractCarFactory {
    @Override
    public Car createCar() {
        return new BCar();
    }
}
```



## 3.抽象工厂模式：

**定义：**定义个一个接口用于创建相关或者相互依赖的对象，不用指定具体的类

**优点：**具体产品在应用层的代码个隔离，不用关系创建的细节，一系列的产品统一到一起创建

![image-20200811210908158](D:\作业\笔记\设计模式\image\image-20200811210908158.png)

==工厂==

```java
public abstract class AbstractFactory {
    public abstract Phone createPhone();
    public abstract Route createRoute() ;
}
```

==phone==

```java
public abstract class Phone {abstract void buy();}
```

==Route==

```java
public abstract class Route {abstract void buy();}
```

==HuaWeiFacory==

```java
public class HuaWeiFactory extends AbstractFactory {
    @Override
    public Phone createPhone() {
        return new HuaWeiPhone();
    }

    @Override
    public Route createRoute() {
        return new HuaWeiRoure();
    }
}
```

==client==

```java
public class Client {
    private  AbstractFactory factory;
    public Client(AbstractFactory factory) {
        this.factory = factory;
    }
    public static void main(String[] args) {
        new Client(new HuaWeiFactory()).factory.createPhone();
    }
}
买了一个华为手机
```





## 4.jdk中使用的简单工厂模式-Calendar

```java
private static Calendar createCalendar(TimeZone zone,
                                       Locale aLocale)
{
    CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                             .getCalendarProvider();
    if (provider != null) {
        try {
            return provider.getInstance(zone, aLocale);
        } catch (IllegalArgumentException iae) {
            // fall back to the default instantiation
        }
    }

    Calendar cal = null;

    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType("ca");
        if (caltype != null) {
            switch (caltype) {
            case "buddhist":
            cal = new BuddhistCalendar(zone, aLocale);
                break;
            case "japanese":
                cal = new JapaneseImperialCalendar(zone, aLocale);
                break;
            case "gregory":
                cal = new GregorianCalendar(zone, aLocale);
                break;
            }
        }
    }
    if (cal == null) {
        if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
            cal = new BuddhistCalendar(zone, aLocale);
        } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                   && aLocale.getCountry() == "JP") {
            cal = new JapaneseImperialCalendar(zone, aLocale);
        } else {
            cal = new GregorianCalendar(zone, aLocale);
        }
    }
    return cal;
}
```



# 四、原型模式：Prototype

**基本介绍：**

1.  用原型实例指定创建对象的类，并且通过==拷贝==这些原型，创建新的对象
2.  允许一个对象在创建另外一个可定制的对象，无需知道如何创建的细节
3.  XXX.clone();

**结构：**

Prototype：原型类，声明一个克隆自己的接口

ConcertePrototype：具体的原型类，实现克隆自己的操作





## 1.浅拷贝

1.  对于数据类型是基本数据类型的成员变量，浅拷贝会进行值传递，也就是将属性值复制一份给新对象
2.  对于引用类型的成员变量，==浅拷贝会进行引用传递，将内存地址复制给新的对象==，两个都指向同一个实例，==一个对象修改会影响到另一个对象==

**实现：**

实现 Cloneable接口，重写clone方法，通过调用super.clone();

```java
public class Sheep implements Cloneable {
    public static void main(String[] args) throws Exception {
        Date date = new Date();
        Sheep sheep = new Sheep("肖恩", 18, date);
        Sheep c1 = (Sheep) sheep.clone();
        Sheep c2 = (Sheep) c1.clone();
        System.out.println(sheep );
        System.out.println(c1 );
        System.out.println(c2 );
        System.out.println("======");
        date.setTime(11111);
        System.out.println(sheep);
        System.out.println(c1);
        System.out.println(c2);
    }

    private String name;
    private int age;
    private Date date;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

```



## 2.深拷贝

**介绍：**

1.  复制对象的所有基本数据类型的成员变量
2.  为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象，也就是说==深拷贝要对整个对象进行拷贝==
3.  一个对象的修改不会影响到其他的对象
4.  实现方法：
    *   重写clone方法实现
    *   通过对象序列化实现



重写clone

```java
public class Sheep implements Cloneable {
    public static void main(String[] args) throws Exception {
        Date date = new Date();
        Sheep sheep = new Sheep("肖恩", 18, date);
        Sheep c1 = (Sheep) sheep.clone();
        Sheep c2 = (Sheep) c1.clone();
        System.out.println(sheep);
        System.out.println(c1);
        System.out.println(c2);
        System.out.println("======");
        date.setTime(11111);
        System.out.println(sheep);
        System.out.println(c1);
        System.out.println(c2);
    }

    private String name;
    private int age;
    private Date date;

    @Override
    public Object clone() throws CloneNotSupportedException {
        Sheep o = (Sheep) super.clone();
        o.date = (Date) o.date.clone();
        return o;
    }
```







# 五、建造者模式：Builder

**介绍：**又叫生成器模式，可以将复杂的对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同的表现对象。

建造者模式是一步一步创建一个复杂的对象，他运行用户只通过指定复杂对象的类型和内容就可以构建他们，而不需要知道具体构建的细节

**组成：**

Product：需要建造的产品

Builder：创建Product对象的抽象类/接口 

ConcreteBuilder：具体的建造者，继承/实现Builder

 Director：指挥者，构建一个使用Builder接口的对象，主要是用于创建一个复杂的对象，隔离了客户与对象的生产过程，负责控制产品对象的生产过程



## 1.产品

```java
public  class House {
    private int wall;
    private int basic;
    public void showHouse() {
        System.out.println("房子的地基长："+ basic +",房子的墙长:"+wall);
    }
```



## 2.Builder

```java
public abstract class HouseBuilder {
    protected House house = new House();
    public House getHouse() {
        return house;
    }
    public void setHouse(House house) {
        this.house = house;
    }
    public abstract HouseBuilder builderWall();

    public abstract HouseBuilder builderBasic();

    public House build() {
        builderWall().builderBasic();
        return house;
    }
}
```



## 3.Builder的实现

```java
public class SimpleHouseBuilder extends HouseBuilder{
    @Override
    public HouseBuilder builderWall() {
        house.setWall(10);
        System.out.println("简单模式构建了墙");
        return this;
    }
    @Override
    public HouseBuilder builderBasic() {
        house.setBasic(20);
        System.out.println("简单模式构建了地基");
        return this;
    }
}
```



## 4.测试

```java
public class Client {
    public static void main(String[] args) {
        SimpleHouseBuilder shb = new SimpleHouseBuilder();
        House house = shb.build();
        house.showHouse();
    }
}
```



## 5.变种-静态内部类

**实现方法：**

-   在要构建的类内部创建一个静态内部类 Builder
-   静态内部类的参数与构建类一致
-   构建类的构造参数是 静态内部类，使用静态内部类的变量一一赋值给构建类
-   静态内部类提供参数的 setter 方法，并且返回值是当前 Builder 对象
-   最终提供一个 build 方法构建一个构建类的对象，参数是当前 Builder 对象

可能你会说，这种写法实现太麻烦了，确实需要我们写很多额外的代码，好在前辈们已经开发出了`lombok`来拯救我们，我们只需要引入`lombok`插件，然后在实体类上添加`@Builder`注解，你就可以实用 Builder 模式构建对象了。

------------

```java
public class Student {
    private int age;
    private String name;

    public static void main(String[] args) {
        StudentBuilder studentBuilder = new StudentBuilder();
        Student like = studentBuilder.name("like").age(18).build();
        System.out.println(like);
    }

    private Student(StudentBuilder sb) {
        this.age = sb.age;
        this.name = sb.name;
    }
    //静态内部类
    public static class StudentBuilder {
        private int age;
        private String name;

        public Student build() {
            return new Student(this);
        }
        public StudentBuilder age(int age) {
            this.age = age;
            return this;
        }

        public StudentBuilder name(String name) {
            this.name = name;
            return this;
        }
    }
    ···
```



## 6.jdk中的StringBuilder

```java
public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
```

```java
public interface Appendable {
    Appendable append(CharSequence csq) {}
```



**角色分析**

Appendable接口定义了多个append()方法，即Appendable为抽象建造者，定义了抽象方法

AbstractStringBuilder实现了Appendable接口方法，AbstractStringBuilder已经是建造者了，只是不能实例化

StringBuilder既充当了指挥者又是具体的建造者，建造方法是AbstractStringBuilder完成，而StringBuilder继承了AbstractStringBuilder